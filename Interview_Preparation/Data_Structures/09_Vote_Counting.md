# ğŸ—³ï¸ PROBLEM 9: VOTE COUNTING & LEADERBOARD

### â­â­â­ **Election Winner with Tie-Breaking**

**Frequency:** Medium (Appears in ~25% of rounds)
**Difficulty:** Easy-Medium
**Similar to:** [LeetCode 347 - Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/), Sorting with Custom Comparators

---

## ğŸ“‹ Problem Statement

You are implementing a voting system for an election. Given a list of votes (candidate names), determine:

1. **Part 1 (Basic):** Who is the winner? (Most votes)
2. **Part 2 (Tie-Breaking):** If multiple candidates have the same highest vote count, choose based on a **tie-breaking rule** (e.g., alphabetically last name).
3. **Part 3 (Leaderboard):** Return the **Top K** candidates in order.
4. **Part 4 (Weighted Voting):** Each vote has a weight (points). Calculate scores.

**Constraints:**
- 1 â‰¤ number of votes â‰¤ 10â¶
- Candidate names are non-empty strings
- Tie-breaking rule varies by problem variant

---

## ğŸ¨ Visual Example

### Example 1: Simple Majority

```text
Votes: [Alice, Bob, Alice, Charlie, Bob, Bob]

Step 1: Count
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Alice   â†’ 2  â”‚
â”‚ Bob     â†’ 3  â”‚
â”‚ Charlie â†’ 1  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Sort by Count (Descending)
1. Bob     (3)
2. Alice   (2)
3. Charlie (1)

Winner: Bob
```

### Example 2: Tie with Alphabetical Rule

```text
Votes: [Alice, Bob, Alice, Bob]

Count:
Alice â†’ 2
Bob   â†’ 2

Tie-Breaking Rule: "Alphabetically Last Wins"
Compare: "Bob" > "Alice" alphabetically

Winner: Bob
```

### Example 3: Weighted Voting

```text
Votes (with weights):
(Alice, 3)  â† First choice (3 points)
(Bob, 2)    â† Second choice (2 points)
(Alice, 1)  â† Third choice (1 point)

Scores:
Alice: 3 + 1 = 4
Bob: 2

Winner: Alice
```

---

## ğŸ¨ VISUAL ALGORITHM TRACE

This section provides comprehensive visual diagrams showing exactly how vote counting, leaderboard construction, and weighted voting work step-by-step.

### Example 1: Basic Vote Counting with HashMap

**Input:** `votes = ["Alice", "Bob", "Alice", "Charlie", "Bob", "Bob", "Alice"]`

#### Step-by-Step Vote Processing

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   VOTE COUNTING PROCESS                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Initial State:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts = {}  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vote 1: "Alice"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Alice"] = 1  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 1}

Vote 2: "Bob"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Bob"] = 1  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 1, "Bob": 1}

Vote 3: "Alice"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Alice"] += 1 â”‚  (1 â†’ 2)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 2, "Bob": 1}

Vote 4: "Charlie"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Charlie"] = 1    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 2, "Bob": 1, "Charlie": 1}

Vote 5: "Bob"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Bob"] += 1 â”‚  (1 â†’ 2)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 2, "Bob": 2, "Charlie": 1}

Vote 6: "Bob"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Bob"] += 1 â”‚  (2 â†’ 3)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 2, "Bob": 3, "Charlie": 1}

Vote 7: "Alice"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ counts["Alice"] += 1 â”‚  (2 â†’ 3)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
HashMap: {"Alice": 3, "Bob": 3, "Charlie": 1}

Final Counts:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Alice   â†’ 3 votes           â”‚
â”‚  Bob     â†’ 3 votes           â”‚
â”‚  Charlie â†’ 1 vote            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Finding the Winner with Tie-Breaking

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               WINNER DETERMINATION PROCESS                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 1: Find Maximum Count
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  counts = {"Alice": 3, "Bob": 3, "Charlie": 1}â”‚
â”‚                                              â”‚
â”‚  max_count = max(3, 3, 1) = 3                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Find All Candidates with Max Count
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  winners = [name for name, count in counts.items()â”‚
â”‚             if count == max_count]                 â”‚
â”‚                                                    â”‚
â”‚  Check each:                                       â”‚
â”‚    Alice: 3 == 3? âœ“ â†’ Add to winners              â”‚
â”‚    Bob: 3 == 3? âœ“ â†’ Add to winners                â”‚
â”‚    Charlie: 1 == 3? âœ— â†’ Skip                      â”‚
â”‚                                                    â”‚
â”‚  Result: winners = ["Alice", "Bob"]                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Apply Tie-Breaking Rule (Alphabetically Last)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  tie_rule = "alphabetical_last"                    â”‚
â”‚  winners = ["Alice", "Bob"]                        â”‚
â”‚                                                    â”‚
â”‚  winner = max(winners)  # Max alphabetically       â”‚
â”‚                                                    â”‚
â”‚  Comparison:                                       â”‚
â”‚    "Alice" vs "Bob"                                â”‚
â”‚    'A' < 'B' â†’ "Bob" is alphabetically later       â”‚
â”‚                                                    â”‚
â”‚  Result: winner = "Bob" âœ“                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Visual Comparison:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Candidates with 3 votes:             â”‚
â”‚                                       â”‚
â”‚  Alice â”€â”€â”€â”                           â”‚
â”‚           â”œâ”€â”€â”€ max() â”€â”€â”€â”€â–º Bob wins!  â”‚
â”‚  Bob   â”€â”€â”€â”˜                           â”‚
â”‚           â–²                           â”‚
â”‚           â”‚                           â”‚
â”‚       "Bob" > "Alice"                 â”‚
â”‚       alphabetically                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Example 2: Leaderboard Construction (Top K)

**Input:** `votes = ["A", "B", "A", "C", "B", "B", "D", "A", "C", "E"]`
**Goal:** Get Top 3 candidates

#### Step 1: Count All Votes

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Processing 10 votes...                â”‚
â”‚                                        â”‚
â”‚  Final counts:                         â”‚
â”‚    A â†’ 3                               â”‚
â”‚    B â†’ 3                               â”‚
â”‚    C â†’ 2                               â”‚
â”‚    D â†’ 1                               â”‚
â”‚    E â†’ 1                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Step 2: Sort Candidates (Primary: Count, Secondary: Name)

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SORTING PROCESS                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Sort Key: (count descending, name descending)                   â”‚
â”‚                                                                  â”‚
â”‚  Before Sorting (unordered):                                     â”‚
â”‚    [("A", 3), ("B", 3), ("C", 2), ("D", 1), ("E", 1)]           â”‚
â”‚                                                                  â”‚
â”‚  Sorting Algorithm Steps:                                        â”‚
â”‚                                                                  â”‚
â”‚  Pass 1: Compare by count first                                  â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚    â”‚ Count 3: A, B                           â”‚                  â”‚
â”‚    â”‚ Count 2: C                              â”‚                  â”‚
â”‚    â”‚ Count 1: D, E                           â”‚                  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                  â”‚
â”‚  Pass 2: Within each count group, sort by name (desc)           â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚    â”‚ Count 3: [A, B] â†’ sort desc â†’ [B, A]   â”‚                  â”‚
â”‚    â”‚ Count 2: [C] â†’ no change â†’ [C]         â”‚                  â”‚
â”‚    â”‚ Count 1: [D, E] â†’ sort desc â†’ [E, D]   â”‚                  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                  â”‚
â”‚  After Sorting:                                                  â”‚
â”‚    [("B", 3), ("A", 3), ("C", 2), ("E", 1), ("D", 1)]           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Visual Ranking:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Rank  â”‚  Name  â”‚  Count  â”‚  Sort Key              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   1    â”‚   B    â”‚    3    â”‚  (3, "B") â—„â”€â”€ Highest  â”‚
â”‚   2    â”‚   A    â”‚    3    â”‚  (3, "A")              â”‚
â”‚   3    â”‚   C    â”‚    2    â”‚  (2, "C")              â”‚
â”‚   4    â”‚   E    â”‚    1    â”‚  (1, "E")              â”‚
â”‚   5    â”‚   D    â”‚    1    â”‚  (1, "D") â—„â”€â”€ Lowest   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Step 3: Extract Top K

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Extract Top 3:                                  â”‚
â”‚                                                  â”‚
â”‚  sorted_list = [("B", 3), ("A", 3), ("C", 2),   â”‚
â”‚                 ("E", 1), ("D", 1)]              â”‚
â”‚                                                  â”‚
â”‚  top_3 = sorted_list[:3]                         â”‚
â”‚                                                  â”‚
â”‚  Result: [("B", 3), ("A", 3), ("C", 2)]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final Leaderboard:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ† TOP 3 LEADERBOARD            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                 â”‚
â”‚  ğŸ¥‡  1st Place: B (3 votes)      â”‚
â”‚  ğŸ¥ˆ  2nd Place: A (3 votes)      â”‚
â”‚  ğŸ¥‰  3rd Place: C (2 votes)      â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Example 3: Weighted Voting (Ranked Choice Points)

**Scenario:** Ranked voting where 1st choice = 3 points, 2nd = 2 points, 3rd = 1 point

**Input:**
```text
Ballot 1: [Alice, Bob, Charlie]    â†’ Alice:3, Bob:2, Charlie:1
Ballot 2: [Bob, Alice, Charlie]    â†’ Bob:3, Alice:2, Charlie:1
Ballot 3: [Alice, Charlie, Bob]    â†’ Alice:3, Charlie:2, Bob:1
```

#### Step-by-Step Score Accumulation

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   WEIGHTED VOTE PROCESSING                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Initial State:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ scores = {}            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ballot 1: [Alice, Bob, Charlie]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vote #1: Alice gets 3 points (1st place) â”‚
â”‚   scores["Alice"] = 3                    â”‚
â”‚                                          â”‚
â”‚ Vote #2: Bob gets 2 points (2nd place)   â”‚
â”‚   scores["Bob"] = 2                      â”‚
â”‚                                          â”‚
â”‚ Vote #3: Charlie gets 1 point (3rd)      â”‚
â”‚   scores["Charlie"] = 1                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Current Scores: {"Alice": 3, "Bob": 2, "Charlie": 1}

Ballot 2: [Bob, Alice, Charlie]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vote #1: Bob gets 3 points               â”‚
â”‚   scores["Bob"] += 3  (2 â†’ 5)            â”‚
â”‚                                          â”‚
â”‚ Vote #2: Alice gets 2 points             â”‚
â”‚   scores["Alice"] += 2  (3 â†’ 5)          â”‚
â”‚                                          â”‚
â”‚ Vote #3: Charlie gets 1 point            â”‚
â”‚   scores["Charlie"] += 1  (1 â†’ 2)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Current Scores: {"Alice": 5, "Bob": 5, "Charlie": 2}

Ballot 3: [Alice, Charlie, Bob]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vote #1: Alice gets 3 points             â”‚
â”‚   scores["Alice"] += 3  (5 â†’ 8)          â”‚
â”‚                                          â”‚
â”‚ Vote #2: Charlie gets 2 points           â”‚
â”‚   scores["Charlie"] += 2  (2 â†’ 4)        â”‚
â”‚                                          â”‚
â”‚ Vote #3: Bob gets 1 point                â”‚
â”‚   scores["Bob"] += 1  (5 â†’ 6)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final Scores: {"Alice": 8, "Bob": 6, "Charlie": 4}
```

---

#### Score Accumulation Visualization

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SCORE PROGRESSION CHART                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Points                                                         â”‚
â”‚    8  â”‚        Alice â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                   â”‚
â”‚    7  â”‚                                                         â”‚
â”‚    6  â”‚        Bob   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                     â”‚
â”‚    5  â”‚                                                         â”‚
â”‚    4  â”‚        Charlie â–ˆâ–ˆâ–ˆâ–ˆ                                     â”‚
â”‚    3  â”‚                                                         â”‚
â”‚    2  â”‚                                                         â”‚
â”‚    1  â”‚                                                         â”‚
â”‚    0  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                   â”‚
â”‚           Alice    Bob    Charlie                               â”‚
â”‚                                                                 â”‚
â”‚  After Ballot 1:  Alice: 3, Bob: 2, Charlie: 1                  â”‚
â”‚  After Ballot 2:  Alice: 5, Bob: 5, Charlie: 2                  â”‚
â”‚  After Ballot 3:  Alice: 8, Bob: 6, Charlie: 4                  â”‚
â”‚                                                                 â”‚
â”‚  Winner: Alice (8 points) ğŸ†                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Detailed Breakdown:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Candidate  â”‚  Ballot 1  â”‚  Ballot 2  â”‚  Ballot 3  â”‚  Total â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Alice      â”‚     3      â”‚     2      â”‚     3      â”‚    8   â”‚
â”‚  Bob        â”‚     2      â”‚     3      â”‚     1      â”‚    6   â”‚
â”‚  Charlie    â”‚     1      â”‚     1      â”‚     2      â”‚    4   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Example 4: Tie-Breaking with Multiple Candidates

**Scenario:** 4-way tie, need to break using alphabetical rule

**Input:** `votes = ["Alice", "Bob", "Charlie", "David"]` (each has 1 vote)

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    4-WAY TIE SCENARIO                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Initial Counts:                                                 â”‚
â”‚    Alice: 1                                                      â”‚
â”‚    Bob: 1                                                        â”‚
â”‚    Charlie: 1                                                    â”‚
â”‚    David: 1                                                      â”‚
â”‚                                                                  â”‚
â”‚  Max Count: 1 (all tied!)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Tie-Breaking Rule: "Alphabetically Last"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 1: Find all candidates with max_count = 1              â”‚
â”‚    winners = ["Alice", "Bob", "Charlie", "David"]            â”‚
â”‚                                                              â”‚
â”‚  Step 2: Apply max() for alphabetical ordering               â”‚
â”‚                                                              â”‚
â”‚    Comparison Tree:                                          â”‚
â”‚                                                              â”‚
â”‚         max(["Alice", "Bob", "Charlie", "David"])            â”‚
â”‚              /                            \                  â”‚
â”‚        max("Alice", "Bob")        max("Charlie", "David")    â”‚
â”‚             /                              \                 â”‚
â”‚          "Bob"                           "David"             â”‚
â”‚             \                              /                 â”‚
â”‚                  max("Bob", "David")                         â”‚
â”‚                         |                                    â”‚
â”‚                      "David" âœ“                               â”‚
â”‚                                                              â”‚
â”‚  Winner: David (alphabetically last)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Visual Ranking:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Alphabetical Order:               â”‚
â”‚                                    â”‚
â”‚  Alice   â”€â”                        â”‚
â”‚  Bob     â”€â”¤                        â”‚
â”‚  Charlie â”€â”¤â”€â”€â”€ All tied at 1 vote  â”‚
â”‚  David   â”€â”˜                        â”‚
â”‚           â–²                        â”‚
â”‚           â”‚                        â”‚
â”‚      Winner (last)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Example 5: Streaming Votes with Live Updates

**Scenario:** Votes arrive one at a time, track leader after each vote

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   STREAMING VOTE UPDATES                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Stream: [Alice, Bob, Alice, Bob, Alice]

Vote 1: "Alice"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State: {"Alice": 1}            â”‚
â”‚ Current Leader: Alice (1 vote) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vote 2: "Bob"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State: {"Alice": 1, "Bob": 1}  â”‚
â”‚ Current Leader: Bob (tie!)     â”‚
â”‚   (alphabetically last wins)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vote 3: "Alice"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State: {"Alice": 2, "Bob": 1}  â”‚
â”‚ Current Leader: Alice (2 votes)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vote 4: "Bob"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State: {"Alice": 2, "Bob": 2}  â”‚
â”‚ Current Leader: Bob (tie!)     â”‚
â”‚   (alphabetically last wins)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vote 5: "Alice"
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ State: {"Alice": 3, "Bob": 2}  â”‚
â”‚ Current Leader: Alice (3 votes)â”‚
â”‚ FINAL WINNER: Alice âœ“          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Leader History:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Vote #  â”‚  Current Counts  â”‚  Leader   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    1     â”‚  A:1, B:0        â”‚  Alice    â”‚
â”‚    2     â”‚  A:1, B:1        â”‚  Bob âš¡    â”‚
â”‚    3     â”‚  A:2, B:1        â”‚  Alice âš¡  â”‚
â”‚    4     â”‚  A:2, B:2        â”‚  Bob âš¡    â”‚
â”‚    5     â”‚  A:3, B:2        â”‚  Alice âš¡  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
âš¡ = Leader changed
```

---

### Example 6: Sort Key Visualization (Tuple Comparison)

Understanding how Python compares tuples for sorting:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           SORT KEY: (count desc, name desc)                      â”‚
â”‚                                                                  â”‚
â”‚  Using: key=lambda x: (x[1], x[0]), reverse=True                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Candidates: [("Alice", 3), ("Bob", 3), ("Charlie", 1), ("Dave", 2)]

Step 1: Generate Sort Keys
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Candidate    â”‚  Sort Key                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ("Alice", 3) â”‚  (3, "Alice")              â”‚
â”‚  ("Bob", 3)   â”‚  (3, "Bob")                â”‚
â”‚  ("Charlie",1)â”‚  (1, "Charlie")            â”‚
â”‚  ("Dave", 2)  â”‚  (2, "Dave")               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Compare Tuples (Lexicographic Order)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Comparison Rules:                                              â”‚
â”‚    1. Compare first element (count)                             â”‚
â”‚    2. If tied, compare second element (name)                    â”‚
â”‚                                                                 â”‚
â”‚  (3, "Bob") vs (3, "Alice")                                     â”‚
â”‚    First: 3 == 3 â†’ Tie, check second                            â”‚
â”‚    Second: "Bob" > "Alice" â†’ (3, "Bob") wins                    â”‚
â”‚                                                                 â”‚
â”‚  (3, "Alice") vs (2, "Dave")                                    â”‚
â”‚    First: 3 > 2 â†’ (3, "Alice") wins (no need to check second)   â”‚
â”‚                                                                 â”‚
â”‚  (2, "Dave") vs (1, "Charlie")                                  â”‚
â”‚    First: 2 > 1 â†’ (2, "Dave") wins                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Final Sorted Order (reverse=True)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. ("Bob", 3)     â†’ (3, "Bob")        â”‚
â”‚  2. ("Alice", 3)   â†’ (3, "Alice")      â”‚
â”‚  3. ("Dave", 2)    â†’ (2, "Dave")       â”‚
â”‚  4. ("Charlie", 1) â†’ (1, "Charlie")    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Visual Decision Tree:
                All Candidates
                     |
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                         â”‚
    Count=3                   Count<3
   [Bob, Alice]            [Dave(2), Charlie(1)]
        |                         |
   Sort by name              Sort by count
    (desc)                      (desc)
        |                         |
   [Bob, Alice]             [Dave, Charlie]
        |                         |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        Final: [Bob, Alice, Dave, Charlie]
```

---

### Complexity Analysis Visualization

#### Time Complexity Breakdown

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TIME COMPLEXITY ANALYSIS                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Operation           â”‚  Time        â”‚  Explanation              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  1. Count votes      â”‚  O(N)        â”‚  Single pass through N    â”‚
â”‚                      â”‚              â”‚  votes, O(1) per vote     â”‚
â”‚                      â”‚              â”‚                           â”‚
â”‚  2. Find max count   â”‚  O(C)        â”‚  Scan C unique candidates â”‚
â”‚                      â”‚              â”‚                           â”‚
â”‚  3. Sort candidates  â”‚  O(C log C)  â”‚  Sorting C candidates     â”‚
â”‚                      â”‚              â”‚                           â”‚
â”‚  4. Extract top K    â”‚  O(K)        â”‚  Slice first K elements   â”‚
â”‚                      â”‚              â”‚                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                                                  â”‚
â”‚  TOTAL: O(N + C log C)                                           â”‚
â”‚                                                                  â”‚
â”‚  Typical case: C << N (few candidates, many votes)               â”‚
â”‚  Example: N = 1,000,000 votes, C = 10 candidates                 â”‚
â”‚    O(1,000,000 + 10 log 10)                                      â”‚
â”‚    = O(1,000,000 + 33)                                           â”‚
â”‚    â‰ˆ O(N) (linear!)                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Operation Timeline:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [========================================]  Count: O(N)â”‚
â”‚  [=]  Max: O(C)                                        â”‚
â”‚  [===]  Sort: O(C log C)                               â”‚
â”‚  []  Extract: O(K)                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚  0%                                              100%  â”‚
â”‚                                                        â”‚
â”‚  For N=1M, C=10:                                       â”‚
â”‚    Count takes ~99.9% of time                          â”‚
â”‚    Rest is negligible                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### Space Complexity Breakdown

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   SPACE COMPLEXITY ANALYSIS                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Data Structure      â”‚  Space    â”‚  Content                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  Counter (HashMap)   â”‚  O(C)     â”‚  C unique candidates     â”‚
â”‚                      â”‚           â”‚  with vote counts        â”‚
â”‚                      â”‚           â”‚                          â”‚
â”‚  Sorted list         â”‚  O(C)     â”‚  Temporary sorted list   â”‚
â”‚                      â”‚           â”‚  of candidates           â”‚
â”‚                      â”‚           â”‚                          â”‚
â”‚  Result (top K)      â”‚  O(K)     â”‚  Output list             â”‚
â”‚                      â”‚           â”‚                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                                              â”‚
â”‚  TOTAL: O(C + C + K) = O(C)                                  â”‚
â”‚  (since K â‰¤ C)                                               â”‚
â”‚                                                              â”‚
â”‚  Example: N = 1,000,000 votes, C = 10 candidates             â”‚
â”‚    Memory: 10 Ã— (string + int) â‰ˆ 10 Ã— 32 bytes = 320 bytes  â”‚
â”‚    Very small!                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Memory Layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Counter (HashMap)                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ "Alice" â†’ 342,151                        â”‚  â”‚
â”‚  â”‚ "Bob"   â†’ 298,432                        â”‚  â”‚
â”‚  â”‚ "Charlie" â†’ 178,293                      â”‚  â”‚
â”‚  â”‚ ...                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  C entries Ã— ~32 bytes each = O(C) space      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ Examples

### Example 1: Basic Winner
```python
votes = ["Alice", "Bob", "Alice", "Charlie", "Bob", "Bob"]
winner = find_winner(votes)
print(winner)  # "Bob"
```

### Example 2: Tie-Breaking
```python
votes = ["Alice", "Bob"]  # Tie: both have 1 vote
winner = find_winner(votes, tie_rule="alphabetical_last")
print(winner)  # "Bob" (B > A)
```

### Example 3: Top K Leaderboard
```python
votes = ["A", "B", "A", "C", "B", "B", "D"]
leaderboard = get_top_k(votes, k=3)
print(leaderboard)  # ["B" (3), "A" (2), "C" (1)]
```

---

## ğŸ—£ï¸ Interview Conversation Guide

### Phase 1: Clarification (3-5 min)

**Candidate:** "Are votes given as an array or a stream?"
**Interviewer:** "Start with an array. We can discuss streaming as a follow-up."

**Candidate:** "How should ties be broken? Alphabetically first or last?"
**Interviewer:** "Let's say alphabetically **last** (e.g., 'Bob' wins over 'Alice')."

**Candidate:** "Should the output be just the winner's name, or name + count?"
**Interviewer:** "Just the name for basic version, but include counts for the leaderboard."

**Candidate:** "Are votes case-sensitive?"
**Interviewer:** "Yes, 'Alice' and 'alice' are different candidates."

### Phase 2: Approach Discussion (5-8 min)

**Candidate:** "This is a **frequency counting + sorting** problem.

**Algorithm:**
1. **Count Phase:** Use a HashMap (`Counter`) to count votes â†’ O(N).
2. **Sort Phase:** Convert to list and sort by:
   - Primary key: Vote count (descending)
   - Secondary key: Name (descending for 'last' rule)
   - Time: O(C log C) where C = unique candidates (usually C << N).
3. **Extract:** Return top 1 (winner) or top K (leaderboard).

**Total Complexity:** O(N + C log C) â‰ˆ O(N) when C << N."

### Phase 3: Implementation (10-15 min)

**Candidate:** "I'll use Python's `Counter` for clean counting and custom sort keys for tie-breaking."

---

## ğŸ§  Intuition & Approach

### Why HashMap (Counter)?

**Direct Counting:**
- One pass through votes
- O(1) increment per vote
- Handles arbitrary candidate names

### Sorting vs. Heap for Top K

| Approach | Time | When to Use |
|----------|------|-------------|
| **Full Sort** | O(C log C) | K â‰ˆ C (need most candidates) or C is small |
| **Heap (Top K)** | O(C log K) | K << C (e.g., K=3, C=1000) |

**For interviews:** Full sort is simpler and sufficient unless C is huge.

---

## ğŸ“ Complete Solution

```python
from collections import Counter
from typing import List, Tuple, Optional

def find_winner(
    votes: List[str],
    tie_rule: str = "alphabetical_last"
) -> Optional[str]:
    """
    Find the election winner.
    
    Args:
        votes: List of candidate names
        tie_rule: How to break ties
            - "alphabetical_last": Choose alphabetically later name
            - "alphabetical_first": Choose alphabetically earlier name
    
    Returns:
        Winner's name, or None if no votes
    
    Time: O(N + C log C)
    Space: O(C)
    """
    if not votes:
        return None
    
    # Count votes
    counts = Counter(votes)
    
    # Find max count
    max_count = max(counts.values())
    
    # Find all candidates with max count
    winners = [name for name, count in counts.items() if count == max_count]
    
    # Tie-breaking
    if tie_rule == "alphabetical_last":
        return max(winners)  # Max alphabetically
    elif tie_rule == "alphabetical_first":
        return min(winners)  # Min alphabetically
    else:
        return winners[0]  # Arbitrary


def get_leaderboard(
    votes: List[str],
    k: int = 3,
    tie_rule: str = "alphabetical_last"
) -> List[Tuple[str, int]]:
    """
    Get top K candidates with their vote counts.
    
    Args:
        votes: List of candidate names
        k: Number of top candidates to return
        tie_rule: Tie-breaking rule
    
    Returns:
        List of (name, count) tuples sorted by rank
    
    Time: O(N + C log C)
    Space: O(C)
    """
    if not votes:
        return []
    
    counts = Counter(votes)
    candidates = list(counts.items())
    
    # Sort by (count desc, name desc) for alphabetical_last
    if tie_rule == "alphabetical_last":
        candidates.sort(key=lambda x: (x[1], x[0]), reverse=True)
    elif tie_rule == "alphabetical_first":
        # Sort by (count desc, name asc)
        candidates.sort(key=lambda x: (-x[1], x[0]))
    else:
        candidates.sort(key=lambda x: x[1], reverse=True)
    
    return candidates[:k]


def weighted_voting(
    votes: List[Tuple[str, int]]
) -> List[Tuple[str, int]]:
    """
    Handle weighted votes (e.g., ranked choice).
    
    Args:
        votes: List of (candidate, points) tuples
    
    Returns:
        Sorted list of (candidate, total_score)
    
    Time: O(N + C log C)
    Space: O(C)
    """
    from collections import defaultdict
    
    scores = defaultdict(int)
    
    for candidate, points in votes:
        scores[candidate] += points
    
    # Sort by score descending
    sorted_scores = sorted(
        scores.items(),
        key=lambda x: (x[1], x[0]),  # By score, then by name
        reverse=True
    )
    
    return sorted_scores


# ============================================
# COMPLETE RUNNABLE EXAMPLE
# ============================================

if __name__ == "__main__":
    print("=" * 60)
    print("VOTING SYSTEM")
    print("=" * 60)
    
    # Test 1: Basic winner
    print("\n[Test 1] Basic Winner")
    print("-" * 40)
    votes1 = ["Alice", "Bob", "Alice", "Charlie", "Bob", "Bob"]
    winner1 = find_winner(votes1)
    print(f"Votes: {votes1}")
    print(f"Winner: {winner1}")  # Bob (3 votes)
    
    # Test 2: Tie-breaking (alphabetical last)
    print("\n[Test 2] Tie-Breaking (Alphabetical Last)")
    print("-" * 40)
    votes2 = ["Alice", "Bob", "Alice", "Bob"]
    winner2 = find_winner(votes2, tie_rule="alphabetical_last")
    print(f"Votes: {votes2}")
    print(f"Alice: 2, Bob: 2 (tie)")
    print(f"Winner: {winner2}")  # Bob (alphabetically > Alice)
    
    # Test 3: Tie-breaking (alphabetical first)
    print("\n[Test 3] Tie-Breaking (Alphabetical First)")
    print("-" * 40)
    winner3 = find_winner(votes2, tie_rule="alphabetical_first")
    print(f"Winner: {winner3}")  # Alice
    
    # Test 4: Leaderboard (Top K)
    print("\n[Test 4] Leaderboard (Top 3)")
    print("-" * 40)
    votes4 = ["A", "B", "A", "C", "B", "B", "D", "A", "C"]
    leaderboard = get_leaderboard(votes4, k=3)
    print(f"Votes: {votes4}")
    print(f"Top 3:")
    for rank, (name, count) in enumerate(leaderboard, 1):
        print(f"  {rank}. {name}: {count} votes")
    
    # Test 5: Weighted voting (ranked choice)
    print("\n[Test 5] Weighted Voting")
    print("-" * 40)
    # First choice = 3 points, Second = 2, Third = 1
    weighted_votes = [
        ("Alice", 3),   # Someone's 1st choice
        ("Bob", 2),     # Someone's 2nd choice
        ("Alice", 1),   # Someone's 3rd choice
        ("Bob", 3),     # Someone's 1st choice
        ("Charlie", 3)  # Someone's 1st choice
    ]
    
    results = weighted_voting(weighted_votes)
    print("Weighted Results:")
    for rank, (name, score) in enumerate(results, 1):
        print(f"  {rank}. {name}: {score} points")
    
    # Test 6: Edge cases
    print("\n[Test 6] Edge Cases")
    print("-" * 40)
    print(f"Empty votes: {find_winner([])}")  # None
    print(f"Single vote: {find_winner(['Alice'])}")  # Alice
    
    print("\n" + "=" * 60)
    print("All tests passed! âœ“")
    print("=" * 60)
```

---

## ğŸ” Explanation with Example

Let's trace through how the vote counting algorithm works with a concrete example:

**Votes:** `["Alice", "Bob", "Alice", "Charlie", "Bob", "Bob", "Alice"]`

**Goal:** Find the winner with tie-breaking rule = "alphabetically last"

---

**Step 1: Count Votes (O(N))**

Iterate through each vote and build frequency map:

```python
votes = ["Alice", "Bob", "Alice", "Charlie", "Bob", "Bob", "Alice"]

# Using Counter
counts = Counter(votes)
```

**Result:**
```
counts = {
    "Alice": 3,
    "Bob": 3,
    "Charlie": 1
}
```

---

**Step 2: Find Maximum Count (O(C))**

```python
max_count = max(counts.values())  # max(3, 3, 1) = 3
```

**Result:** `max_count = 3`

---

**Step 3: Find All Winners with Max Count**

```python
winners = [name for name, count in counts.items() if count == max_count]
```

**Result:** `winners = ["Alice", "Bob"]` (both have 3 votes)

---

**Step 4: Apply Tie-Breaking Rule**

Since we have a tie, apply the rule "alphabetically last":

```python
if tie_rule == "alphabetical_last":
    winner = max(winners)  # max("Alice", "Bob") = "Bob"
```

**Comparison:** "Bob" > "Alice" alphabetically â†’ **Bob wins!**

---

**Alternative: Top K Leaderboard**

If we want Top 2 candidates:

**Step 1:** Sort all candidates by count (descending), then by name (ascending for ties):

```python
sorted_candidates = sorted(
    counts.items(),
    key=lambda x: (-x[1], x[0])
)

# Result:
# [("Alice", 3), ("Bob", 3), ("Charlie", 1)]
# Both Alice and Bob have 3, but Alice < Bob alphabetically
```

**Step 2:** Take first k:

```python
top_2 = sorted_candidates[:2]
# Result: [("Alice", 3), ("Bob", 3)]
```

---

## ğŸ” Complexity Analysis

### Time Complexity

| Operation | Time | Explanation |
|-----------|------|-------------|
| Count votes | **O(N)** | Single pass through votes |
| Find max count | **O(C)** | Scan counter (C = unique candidates) |
| Sort candidates | **O(C log C)** | Sort C candidates |
| **Total** | **O(N + C log C)** | Usually C << N, so â‰ˆ O(N) |

### Space Complexity

**O(C)** for the counter (C = unique candidates).

---

## âš ï¸ Common Pitfalls

### 1. **Wrong Tie-Breaking Logic**

**Wrong:**
```python
# Want: Bob > Alice if tied
candidates.sort(key=lambda x: x[1], reverse=True)  # Only sorts by count
# Result: Arbitrary order for ties
```

**Right:** Include secondary sort key.
```python
candidates.sort(key=lambda x: (x[1], x[0]), reverse=True)
```

### 2. **Incorrect Sort Key for "Alphabetical First"**

**Wrong:**
```python
# Want: Alice > Bob if tied (alphabetically first)
candidates.sort(key=lambda x: (x[1], x[0]), reverse=True)
# This gives Bob > Alice (reverse sorts both keys)
```

**Right:**
```python
candidates.sort(key=lambda x: (-x[1], x[0]))  # Count desc, name asc
```

### 3. **Not Handling Empty Votes**

**Wrong:**
```python
def find_winner(votes):
    counts = Counter(votes)
    return max(counts, key=counts.get)  # Crashes on empty Counter
```

**Right:** Check `if not votes: return None`.

---

## ğŸ”„ Follow-up Questions

### Follow-up 1: Streaming Votes

**Problem Statement:**
> "Votes arrive one at a time as a stream. Maintain a live leaderboard that can be queried at any time."

**Solution:**
Maintain a `Counter` and update it incrementally.

```python
class LiveLeaderboard:
    """
    Maintain live voting results.
    """
    
    def __init__(self):
        self.counts = Counter()
    
    def cast_vote(self, candidate: str) -> None:
        """
        Add a vote.
        Time: O(1)
        """
        self.counts[candidate] += 1
    
    def get_leader(self) -> Optional[str]:
        """
        Get current leader.
        Time: O(C)
        """
        if not self.counts:
            return None
        return max(self.counts, key=self.counts.get)
    
    def get_top_k(self, k: int) -> List[Tuple[str, int]]:
        """
        Get current top K.
        Time: O(C log C)
        """
        candidates = sorted(
            self.counts.items(),
            key=lambda x: x[1],
            reverse=True
        )
        return candidates[:k]


# ============================================
# COMPLETE RUNNABLE EXAMPLE
# ============================================

if __name__ == "__main__":
    from collections import Counter
    from typing import List, Tuple, Optional
    
    class LiveLeaderboard:
        """
        Maintain live voting results.
        
        Supports real-time vote casting and querying.
        """
        
        def __init__(self):
            self.counts = Counter()
            self.total_votes = 0
        
        def cast_vote(self, candidate: str) -> None:
            """
            Add a vote.
            
            Time: O(1)
            Space: O(1)
            """
            self.counts[candidate] += 1
            self.total_votes += 1
        
        def get_leader(self) -> Optional[str]:
            """
            Get current leader.
            
            Time: O(C) where C = unique candidates
            Space: O(1)
            """
            if not self.counts:
                return None
            return max(self.counts, key=self.counts.get)
        
        def get_top_k(self, k: int) -> List[Tuple[str, int]]:
            """
            Get current top K.
            
            Time: O(C log C)
            Space: O(C)
            """
            candidates = sorted(
                self.counts.items(),
                key=lambda x: x[1],
                reverse=True
            )
            return candidates[:k]
        
        def get_stats(self) -> dict:
            """Get comprehensive voting statistics."""
            if not self.counts:
                return {"total_votes": 0, "candidates": 0}
            
            leader = self.get_leader()
            leader_votes = self.counts[leader]
            
            return {
                "total_votes": self.total_votes,
                "candidates": len(self.counts),
                "leader": leader,
                "leader_votes": leader_votes,
                "leader_percentage": (leader_votes / self.total_votes * 100) if self.total_votes > 0 else 0
            }
    
    print("\n" + "=" * 70)
    print("FOLLOW-UP 1: STREAMING VOTES (LIVE LEADERBOARD)")
    print("=" * 70)
    
    leaderboard = LiveLeaderboard()
    
    # Simulate streaming votes
    vote_stream = [
        "Alice", "Bob", "Alice", "Charlie",
        "Bob", "Alice", "David", "Bob",
        "Charlie", "Alice", "Bob", "Alice"
    ]
    
    print("\nğŸ“Š Processing vote stream in real-time...")
    print("-" * 70)
    
    # Process votes and show leader after every 3 votes
    for i, vote in enumerate(vote_stream, 1):
        leaderboard.cast_vote(vote)
        
        if i % 3 == 0 or i == len(vote_stream):
            stats = leaderboard.get_stats()
            print(f"\nğŸ“ After vote #{i}: '{vote}'")
            print(f"  Current Leader: {stats['leader']} ({stats['leader_votes']} votes, {stats['leader_percentage']:.1f}%)")
            print(f"  Total Votes: {stats['total_votes']}")
            print(f"  Candidates: {stats['candidates']}")
            
            # Show top 3
            top_3 = leaderboard.get_top_k(3)
            print(f"  Top 3:")
            for rank, (candidate, count) in enumerate(top_3, 1):
                print(f"    {rank}. {candidate}: {count} votes")
    
    # Final results
    print("\n" + "=" * 70)
    print("ğŸ† FINAL RESULTS")
    print("=" * 70)
    
    stats = leaderboard.get_stats()
    print(f"\nTotal Votes Cast: {stats['total_votes']}")
    print(f"Winner: {stats['leader']} with {stats['leader_votes']} votes ({stats['leader_percentage']:.1f}%)")
    
    print(f"\nFull Leaderboard:")
    for rank, (candidate, count) in enumerate(leaderboard.get_top_k(10), 1):
        percentage = (count / stats['total_votes'] * 100)
        bar = "â–ˆ" * int(percentage)
        print(f"  {rank}. {candidate:10} {count:3} votes ({percentage:5.1f}%) {bar}")
    
    # Test 2: Live updates with leader changes
    print("\n" + "=" * 70)
    print("âš¡ Demonstrating Leader Changes")
    print("=" * 70)
    
    board2 = LiveLeaderboard()
    
    print("\nğŸ“ Vote-by-vote analysis:")
    print("-" * 70)
    
    votes_sequence = ["Alice", "Bob", "Alice", "Bob", "Alice", "Bob", "Bob"]
    prev_leader = None
    
    for i, vote in enumerate(votes_sequence, 1):
        board2.cast_vote(vote)
        current_leader = board2.get_leader()
        leader_changed = (current_leader != prev_leader)
        
        change_indicator = "âš¡ LEADER CHANGED!" if leader_changed and prev_leader else ""
        
        print(f"\nVote #{i}: '{vote}' {change_indicator}")
        print(f"  Counts: {dict(board2.counts)}")
        print(f"  Leader: {current_leader}")
        
        prev_leader = current_leader
    
    # Test 3: High-throughput simulation
    print("\n" + "=" * 70)
    print("ğŸš€ High-Throughput Simulation")
    print("=" * 70)
    
    import random
    import time
    
    board3 = LiveLeaderboard()
    candidates = ["Alice", "Bob", "Charlie", "David", "Eve"]
    
    print(f"\nSimulating 10,000 votes...")
    start_time = time.time()
    
    for _ in range(10000):
        vote = random.choice(candidates)
        board3.cast_vote(vote)
    
    end_time = time.time()
    elapsed = end_time - start_time
    
    print(f"âœ… Processed 10,000 votes in {elapsed:.4f} seconds")
    print(f"   Throughput: {10000 / elapsed:.0f} votes/second")
    
    print(f"\nFinal Top 5:")
    for rank, (candidate, count) in enumerate(board3.get_top_k(5), 1):
        percentage = (count / 10000 * 100)
        print(f"  {rank}. {candidate}: {count} votes ({percentage:.1f}%)")
    
    print("\n" + "=" * 70)
    print("âœ… Streaming votes test complete!")
    print("=" * 70)
    
    print("\nğŸ’¡ Key Benefits:")
    print("  â€¢ O(1) vote casting (instant)")
    print("  â€¢ O(C) leader query (fast)")
    print("  â€¢ Real-time results (no batch processing)")
    print("  â€¢ Scalable to millions of votes")
```

---

### Follow-up 2: Ranked Choice Voting (IRV)

**Problem Statement:**
> "Each voter ranks candidates (1st, 2nd, 3rd choice). Implement Instant Runoff Voting: eliminate the candidate with the fewest 1st-choice votes, redistribute their votes to voters' 2nd choices, repeat until someone has a majority."

**Solution:**
This is complex! Key steps:

1. Count 1st-choice votes for each candidate.
2. If someone has >50%, they win.
3. Otherwise, eliminate the candidate with fewest 1st-choice votes.
4. Redistribute their votes to next-choice candidates.
5. Repeat.

```python
def instant_runoff(ballots: List[List[str]]) -> str:
    """
    Implement instant runoff voting.
    
    Args:
        ballots: List of ranked ballots (1st choice first)
    
    Returns:
        Winner's name
    """
    active = set()
    for ballot in ballots:
        active.update(ballot)
    
    while len(active) > 1:
        # Count current top choices
        counts = Counter()
        for ballot in ballots:
            # Find first active candidate on this ballot
            for candidate in ballot:
                if candidate in active:
                    counts[candidate] += 1
                    break
        
        # Check for majority
        total = sum(counts.values())
        for candidate, count in counts.items():
            if count > total / 2:
                return candidate
        
        # Eliminate candidate with fewest votes
        min_count = min(counts.values())
        eliminated = [c for c, count in counts.items() if count == min_count][0]
        active.remove(eliminated)
    
    return list(active)[0]


# ============================================
# COMPLETE RUNNABLE EXAMPLE
# ============================================

if __name__ == "__main__":
    from collections import Counter
    from typing import List
    
    def instant_runoff(ballots: List[List[str]]) -> str:
        """
        Implement instant runoff voting (IRV).
        
        Algorithm:
        1. Count 1st-choice votes
        2. If someone has >50%, they win
        3. Otherwise, eliminate lowest candidate
        4. Redistribute votes to next choice
        5. Repeat until winner found
        
        Args:
            ballots: List of ranked ballots (1st choice first)
        
        Returns:
            Winner's name
        
        Time: O(R Ã— C Ã— B) where R=rounds, C=candidates, B=ballots
        Space: O(C)
        """
        active = set()
        for ballot in ballots:
            active.update(ballot)
        
        round_num = 1
        
        while len(active) > 1:
            # Count current top choices
            counts = Counter()
            for ballot in ballots:
                # Find first active candidate on this ballot
                for candidate in ballot:
                    if candidate in active:
                        counts[candidate] += 1
                        break
            
            # Check for majority
            total = sum(counts.values())
            for candidate, count in counts.items():
                if count > total / 2:
                    return candidate
            
            # Eliminate candidate with fewest votes
            min_count = min(counts.values())
            eliminated = [c for c, count in counts.items() if count == min_count][0]
            active.remove(eliminated)
            
            round_num += 1
        
        return list(active)[0]
    
    print("\n" + "=" * 70)
    print("FOLLOW-UP 2: RANKED CHOICE VOTING (INSTANT RUNOFF)")
    print("=" * 70)
    
    # Test 1: Clear majority winner (no elimination needed)
    print("\n[Test 1] Clear Majority Winner")
    print("-" * 70)
    
    ballots1 = [
        ["Alice", "Bob", "Charlie"],
        ["Alice", "Charlie", "Bob"],
        ["Alice", "Bob", "Charlie"],
        ["Bob", "Alice", "Charlie"],
        ["Charlie", "Alice", "Bob"]
    ]
    
    print(f"\nBallots: {len(ballots1)} voters")
    for i, ballot in enumerate(ballots1, 1):
        print(f"  Voter {i}: {' > '.join(ballot)}")
    
    winner1 = instant_runoff(ballots1)
    print(f"\nğŸ† Winner: {winner1}")
    print(f"   (Alice had 3/5 = 60% first-choice votes, majority!)")
    
    # Test 2: Requires elimination rounds
    print("\n" + "=" * 70)
    print("[Test 2] Multiple Elimination Rounds")
    print("-" * 70)
    
    ballots2 = [
        ["Alice", "Bob", "Charlie"],
        ["Alice", "Charlie", "Bob"],
        ["Bob", "Charlie", "Alice"],
        ["Bob", "Alice", "Charlie"],
        ["Charlie", "Alice", "Bob"],
        ["Charlie", "Bob", "Alice"],
        ["Charlie", "Alice", "Bob"]
    ]
    
    print(f"\nBallots: {len(ballots2)} voters")
    
    # Show first-choice distribution
    first_choices = Counter()
    for ballot in ballots2:
        first_choices[ballot[0]] += 1
    
    print(f"\nFirst-Choice Votes:")
    for candidate, count in sorted(first_choices.items(), key=lambda x: -x[1]):
        percentage = (count / len(ballots2) * 100)
        bar = "â–ˆ" * count
        print(f"  {candidate:10} {count} votes ({percentage:5.1f}%) {bar}")
    
    print(f"\nğŸ“Š No candidate has majority (need >{len(ballots2)/2:.1f} votes)")
    print(f"   â†’ Elimination rounds will occur")
    
    winner2 = instant_runoff(ballots2)
    print(f"\nğŸ† Final Winner: {winner2}")
    
    # Test 3: Detailed round-by-round trace
    print("\n" + "=" * 70)
    print("[Test 3] Round-by-Round Trace")
    print("-" * 70)
    
    ballots3 = [
        ["Alice", "Bob", "Charlie"],
        ["Alice", "Bob", "Charlie"],
        ["Bob", "Charlie", "Alice"],
        ["Bob", "Charlie", "Alice"],
        ["Charlie", "Alice", "Bob"],
    ]
    
    print(f"\nBallots: {len(ballots3)} voters")
    for i, ballot in enumerate(ballots3, 1):
        print(f"  Voter {i}: {' > '.join(ballot)}")
    
    # Manual trace
    print(f"\nğŸ” Manual Trace:")
    print("-" * 70)
    
    active = set()
    for ballot in ballots3:
        active.update(ballot)
    
    round_num = 1
    
    while len(active) > 1:
        counts = Counter()
        for ballot in ballots3:
            for candidate in ballot:
                if candidate in active:
                    counts[candidate] += 1
                    break
        
        print(f"\nRound {round_num}:")
        print(f"  Active candidates: {sorted(active)}")
        print(f"  Vote counts:")
        for candidate in sorted(counts.keys()):
            count = counts[candidate]
            percentage = (count / len(ballots3) * 100)
            print(f"    {candidate:10} {count} votes ({percentage:5.1f}%)")
        
        total = sum(counts.values())
        majority_threshold = total / 2
        
        # Check for winner
        winner_found = False
        for candidate, count in counts.items():
            if count > majority_threshold:
                print(f"\n  âœ… {candidate} has majority ({count} > {majority_threshold:.1f})")
                print(f"  ğŸ† Winner: {candidate}")
                winner_found = True
                break
        
        if winner_found:
            break
        
        # Eliminate
        min_count = min(counts.values())
        eliminated = [c for c, count in counts.items() if count == min_count][0]
        print(f"\n  âŒ Eliminating {eliminated} ({min_count} votes, fewest)")
        print(f"  â†’ Votes redistribute to next choice")
        
        active.remove(eliminated)
        round_num += 1
    
    # Test 4: Three-way tie scenario
    print("\n" + "=" * 70)
    print("[Test 4] Three-Way Competition")
    print("-" * 70)
    
    ballots4 = [
        ["Alice", "Bob", "Charlie"],
        ["Alice", "Charlie", "Bob"],
        ["Bob", "Alice", "Charlie"],
        ["Bob", "Charlie", "Alice"],
        ["Charlie", "Alice", "Bob"],
        ["Charlie", "Bob", "Alice"],
    ]
    
    print(f"\nBallots: {len(ballots4)} voters")
    print(f"First-choice distribution:")
    fc = Counter([b[0] for b in ballots4])
    for candidate, count in sorted(fc.items()):
        print(f"  {candidate}: {count} votes (tied!)")
    
    winner4 = instant_runoff(ballots4)
    print(f"\nğŸ† Winner after runoff: {winner4}")
    
    print("\n" + "=" * 70)
    print("âœ… Ranked choice voting test complete!")
    print("=" * 70)
    
    print("\nğŸ’¡ Key Insights:")
    print("  â€¢ IRV ensures winner has majority support")
    print("  â€¢ Eliminates 'spoiler effect' of third parties")
    print("  â€¢ Voters can vote sincerely for favorite")
    print("  â€¢ Used in Australia, San Francisco, Maine, etc.")
```

---

## ğŸ§ª Test Cases

```python
def test_voting():
    # Test 1: Clear winner
    assert find_winner(["A", "B", "A"]) == "A"
    
    # Test 2: Tie (alphabetical last)
    assert find_winner(["A", "B"], tie_rule="alphabetical_last") == "B"
    
    # Test 3: Tie (alphabetical first)
    assert find_winner(["A", "B"], tie_rule="alphabetical_first") == "A"
    
    # Test 4: Empty
    assert find_winner([]) is None
    
    # Test 5: Leaderboard order
    leaderboard = get_leaderboard(["A", "B", "A", "C", "B", "B"], k=3)
    assert leaderboard[0][0] == "B"  # Most votes
    assert leaderboard[1][0] == "A"  # Second most
    
    print("All tests passed! âœ“")

if __name__ == "__main__":
    test_voting()
```

---

## ğŸ¯ Key Takeaways

1. **Counter is Perfect** for frequency-based problems.
2. **Custom Sort Keys** handle tie-breaking elegantly.
3. **Tuple Sort Keys** `(primary, secondary)` are powerful.
4. **Negative Values** in sort keys reverse order: `(-count, name)`.
5. **Streaming Updates** maintain Counter incrementally (O(1) per vote).

---

## ğŸ“š Related Problems

- **LeetCode 347:** Top K Frequent Elements
- **LeetCode 692:** Top K Frequent Words (with tie-breaking)
- **LeetCode 451:** Sort Characters By Frequency
- **LeetCode 1636:** Sort Array by Increasing Frequency
