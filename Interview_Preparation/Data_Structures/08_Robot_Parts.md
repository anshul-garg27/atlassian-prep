# ğŸ¤– PROBLEM 8: ROBOT PARTS ASSEMBLY

### â­â­ **Inventory Management with Multi-Set Matching**

**Frequency:** Low-Medium (Appears in ~20% of rounds)
**Difficulty:** Easy-Medium
**Similar to:** [LeetCode 383 - Ransom Note](https://leetcode.com/problems/ransom-note/), [LeetCode 1657 - Determine if Two Strings Are Close](https://leetcode.com/problems/determine-if-two-strings-are-close/)

---

## ğŸ“‹ Problem Statement

You are managing a robot assembly factory. Each robot requires a specific **multiset** of parts (e.g., 2 wheels, 1 motor, 3 sensors).

Given:
- **Inventory:** A list of available parts
- **Requirements:** A list of parts needed to build one robot

**Operations:**
1. `canBuild(requirements)`: Check if the inventory has enough parts
2. `build(requirements)`: If possible, consume the parts and return success. Otherwise, return the list of missing parts.

**Constraints:**
- Part names are case-sensitive strings
- Duplicates matter (a robot might need 4 identical wheels)
- 1 â‰¤ inventory size â‰¤ 10â¶
- 1 â‰¤ requirements size â‰¤ 100

---

## ğŸ¨ Visual Example

### Example 1: Successful Build

```text
Inventory: [wheel, wheel, motor, sensor, cable, wheel]

Robot Requirements: [wheel, wheel, motor]

Step 1: Count Requirements
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ wheel  â†’ 2          â”‚
â”‚ motor  â†’ 1          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Count Inventory
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ wheel  â†’ 3          â”‚
â”‚ motor  â†’ 1          â”‚
â”‚ sensor â†’ 1          â”‚
â”‚ cable  â†’ 1          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Validate
âœ“ wheel: need 2, have 3 â†’ OK
âœ“ motor: need 1, have 1 â†’ OK

Step 4: Consume Parts
Inventory After: [wheel, sensor, cable]
```

### Example 2: Insufficient Parts

```text
Inventory: [wheel, motor]

Requirements: [wheel, wheel, motor]

Count Comparison:
âœ— wheel: need 2, have 1 â†’ MISSING 1

Result: Cannot build
Missing: ["wheel (x1)"]
```

---

## ğŸ¨ VISUAL ALGORITHM TRACE

This section provides comprehensive visual diagrams showing inventory management, atomic transactions, and state transitions.

### Complete Build Process with State Transitions

**Scenario:** Build a robot requiring `["wheel", "wheel", "motor"]`

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ROBOT BUILD STATE MACHINE                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Initial State:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  INVENTORY (Counter)                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  "wheel"  â†’ 3                                 â”‚  â”‚
â”‚  â”‚  "motor"  â†’ 1                                 â”‚  â”‚
â”‚  â”‚  "sensor" â†’ 2                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  Total Parts: 6                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Build Request: ["wheel", "wheel", "motor"]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 1: INITIALIZATION                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Step 1: Create requirements Counter                            â”‚
â”‚    Input: ["wheel", "wheel", "motor"]                           â”‚
â”‚    Counter(["wheel", "wheel", "motor"])                         â”‚
â”‚                                                                 â”‚
â”‚  Result:                                                        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚    â”‚  "wheel" â†’ 2        â”‚                                      â”‚
â”‚    â”‚  "motor" â†’ 1        â”‚                                      â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 2: VALIDATION (Check All Parts BEFORE Consuming)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Check 1: "wheel"                                               â”‚
â”‚    Need: 2                                                      â”‚
â”‚    Have: 3                                                      â”‚
â”‚    3 >= 2? âœ“ PASS                                               â”‚
â”‚                                                                 â”‚
â”‚  Check 2: "motor"                                               â”‚
â”‚    Need: 1                                                      â”‚
â”‚    Have: 1                                                      â”‚
â”‚    1 >= 1? âœ“ PASS                                               â”‚
â”‚                                                                 â”‚
â”‚  Validation Result: ALL CHECKS PASSED âœ“                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 3: COMMIT (Atomic Update)                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Update 1: wheel                                                â”‚
â”‚    inventory["wheel"] -= 2                                      â”‚
â”‚    3 â†’ 1                                                        â”‚
â”‚                                                                 â”‚
â”‚  Update 2: motor                                                â”‚
â”‚    inventory["motor"] -= 1                                      â”‚
â”‚    1 â†’ 0 (remove from Counter)                                  â”‚
â”‚                                                                 â”‚
â”‚  Updates Complete âœ“                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final State:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  INVENTORY (Counter) - AFTER BUILD                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  "wheel"  â†’ 1  (was 3, used 2)               â”‚  â”‚
â”‚  â”‚  "sensor" â†’ 2  (unchanged)                    â”‚  â”‚
â”‚  â”‚  "motor"  â†’ (removed, was 1, used 1)          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  Total Parts: 3                                     â”‚
â”‚  Build Status: SUCCESS âœ“                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Atomic Transaction Visualization (Check-Then-Act Pattern)

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ATOMIC TRANSACTION GUARANTEE                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  WITHOUT ATOMICITY (âŒ WRONG):                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Step 1: Check wheel â†’ OK, consume 1 wheel                 â”‚ â”‚
â”‚  â”‚ Step 2: Check wheel again â†’ OK, consume 1 wheel           â”‚ â”‚
â”‚  â”‚ Step 3: Check motor â†’ FAIL! (out of stock)                â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ Problem: We consumed 2 wheels but can't build robot!      â”‚ â”‚
â”‚  â”‚ Inventory is now CORRUPTED                                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â”‚  WITH ATOMICITY (âœ“ CORRECT):                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Phase 1: VALIDATE (NO modifications)                      â”‚ â”‚
â”‚  â”‚   â”œâ”€ Check wheel (need 2): 3 >= 2? âœ“                      â”‚ â”‚
â”‚  â”‚   â””â”€ Check motor (need 1): 0 >= 1? âœ— ABORT!               â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ Phase 2: COMMIT (only if ALL validated)                   â”‚ â”‚
â”‚  â”‚   â”œâ”€ Validation failed â†’ Skip this phase                  â”‚ â”‚
â”‚  â”‚   â””â”€ Inventory remains UNCHANGED                          â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ Result: Either ALL parts consumed or NONE                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Timeline Comparison:

WITHOUT ATOMICITY:
Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
  â”‚  Check  Consume  Check  Consume  Check  âœ— FAIL
  â”‚  wheel    wheel  wheel    wheel  motor
  â”‚   âœ“       âœ“      âœ“       âœ“      âœ—
  â”‚
  â””â”€â–º Inventory CORRUPTED! (2 wheels gone, no robot built)

WITH ATOMICITY:
Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
  â”‚  Check  Check  Check  â”‚  Consume  Consume
  â”‚  wheel  wheel  motor  â”‚  all      all
  â”‚   âœ“      âœ“      âœ“     â”‚  parts    parts
  â”‚                       â”‚
  â””â”€â”€â”€â”€â”€ VALIDATE â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€ COMMIT â”€â”€â”€â”€â–º

  Result: Clean transaction (all-or-nothing)
```

---

### Failed Build with Rollback

**Scenario:** Attempt to build robot but insufficient parts

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FAILED BUILD SCENARIO                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Starting Inventory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  "wheel"  â†’ 1                â”‚
â”‚  "sensor" â†’ 2                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Build Request: ["wheel", "wheel", "motor"]
Required Counter:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  "wheel"  â†’ 2                â”‚
â”‚  "motor"  â†’ 1                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Validation Phase:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Check 1: "wheel"                                          â”‚
â”‚    Need: 2                                                 â”‚
â”‚    Have: 1                                                 â”‚
â”‚    1 >= 2? âœ— FAIL                                          â”‚
â”‚    Shortage: 2 - 1 = 1                                     â”‚
â”‚    Missing: "wheel (need 2, have 1)"                       â”‚
â”‚                                                            â”‚
â”‚  Check 2: "motor"                                          â”‚
â”‚    Need: 1                                                 â”‚
â”‚    Have: 0                                                 â”‚
â”‚    0 >= 1? âœ— FAIL                                          â”‚
â”‚    Shortage: 1 - 0 = 1                                     â”‚
â”‚    Missing: "motor (need 1, have 0)"                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Result:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Validation FAILED âœ—                                       â”‚
â”‚                                                            â”‚
â”‚  Missing Parts:                                            â”‚
â”‚    â€¢ wheel (need 1 more)                                   â”‚
â”‚    â€¢ motor (need 1 more)                                   â”‚
â”‚                                                            â”‚
â”‚  Action: ABORT - No modifications to inventory            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final Inventory (UNCHANGED):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  "wheel"  â†’ 1  (same)        â”‚
â”‚  "sensor" â†’ 2  (same)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Build Status: FAILED âœ—
```

---

### Multiple Robot Builds (Inventory Depletion)

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              BUILD MULTIPLE ROBOTS SEQUENCE                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Starting Inventory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Parts: ["wheel"] Ã— 6 + ["motor"] Ã— 3 + ["sensor"] Ã— 2    â”‚
â”‚                                                            â”‚
â”‚  Counter:                                                  â”‚
â”‚    wheel: 6   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                â”‚
â”‚    motor: 3   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                       â”‚
â”‚    sensor: 2  â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Robot Template: ["wheel", "wheel", "motor"]

Build #1:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Request: ["wheel", "wheel", "motor"]                      â”‚
â”‚  Validation: âœ“ All parts available                         â”‚
â”‚  Consume: wheel: 6â†’4, motor: 3â†’2                           â”‚
â”‚                                                            â”‚
â”‚  Inventory After Build #1:                                 â”‚
â”‚    wheel: 4   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                     â”‚
â”‚    motor: 2   â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â”‚    sensor: 2  â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â”‚                                                            â”‚
â”‚  Status: SUCCESS âœ“ (1 robot built)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Build #2:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Request: ["wheel", "wheel", "motor"]                      â”‚
â”‚  Validation: âœ“ All parts available                         â”‚
â”‚  Consume: wheel: 4â†’2, motor: 2â†’1                           â”‚
â”‚                                                            â”‚
â”‚  Inventory After Build #2:                                 â”‚
â”‚    wheel: 2   â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â”‚    motor: 1   â–ˆâ–ˆ                                           â”‚
â”‚    sensor: 2  â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â”‚                                                            â”‚
â”‚  Status: SUCCESS âœ“ (2 robots built total)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Build #3:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Request: ["wheel", "wheel", "motor"]                      â”‚
â”‚  Validation: âœ“ All parts available                         â”‚
â”‚  Consume: wheel: 2â†’0, motor: 1â†’0                           â”‚
â”‚                                                            â”‚
â”‚  Inventory After Build #3:                                 â”‚
â”‚    wheel: 0   (removed)                                    â”‚
â”‚    motor: 0   (removed)                                    â”‚
â”‚    sensor: 2  â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â”‚                                                            â”‚
â”‚  Status: SUCCESS âœ“ (3 robots built total)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Build #4:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Request: ["wheel", "wheel", "motor"]                      â”‚
â”‚  Validation:                                               â”‚
â”‚    wheel: need 2, have 0 âœ—                                 â”‚
â”‚    motor: need 1, have 0 âœ—                                 â”‚
â”‚                                                            â”‚
â”‚  Missing: ["wheel (need 2, have 0)", "motor (need 1, have 0)"]â”‚
â”‚                                                            â”‚
â”‚  Inventory UNCHANGED:                                      â”‚
â”‚    sensor: 2  â–ˆâ–ˆâ–ˆâ–ˆ                                         â”‚
â”‚                                                            â”‚
â”‚  Status: FAILED âœ— (3 robots built total, stopped)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Summary:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Total Robots Built: 3                                     â”‚
â”‚  Total Parts Consumed:                                     â”‚
â”‚    â€¢ 6 wheels (all used)                                   â”‚
â”‚    â€¢ 3 motors (all used)                                   â”‚
â”‚    â€¢ 0 sensors (none used)                                 â”‚
â”‚                                                            â”‚
â”‚  Remaining Inventory: 2 sensors                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Concurrent Builds with Thread Safety

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CONCURRENT BUILD SCENARIO                        â”‚
â”‚                    (Thread Safety Test)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Starting Inventory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  wheel: 3                    â”‚
â”‚  motor: 2                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3 Threads trying to build simultaneously:
Thread A: ["wheel", "motor"]
Thread B: ["wheel", "motor"]
Thread C: ["wheel", "motor"]

WITHOUT LOCK (âŒ Race Condition):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Time  â”‚  Thread A      â”‚  Thread B      â”‚  Thread C           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  t0    â”‚  Check wheel:3 â”‚                â”‚                    â”‚
â”‚  t1    â”‚  Check motor:2 â”‚  Check wheel:3 â”‚                    â”‚
â”‚  t2    â”‚  âœ“ Valid       â”‚  Check motor:2 â”‚  Check wheel:3     â”‚
â”‚  t3    â”‚  Consume parts â”‚  âœ“ Valid       â”‚  Check motor:2     â”‚
â”‚  t4    â”‚  wheel:3â†’2     â”‚  Consume parts â”‚  âœ“ Valid           â”‚
â”‚  t5    â”‚  motor:2â†’1     â”‚  wheel:2â†’1     â”‚  Consume parts     â”‚
â”‚  t6    â”‚                â”‚  motor:1â†’0     â”‚  wheel:1â†’0         â”‚
â”‚  t7    â”‚                â”‚                â”‚  motor:0â†’-1 âŒ BUG! â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Problem: 3 robots "built" but only had parts for 2!
Inventory corrupted: motor = -1 (impossible!)

WITH LOCK (âœ“ Thread-Safe):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Time  â”‚  Thread A        â”‚  Thread B        â”‚  Thread C       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  t0    â”‚  LOCK acquired   â”‚  Waiting...      â”‚  Waiting...    â”‚
â”‚  t1    â”‚  Check: âœ“ Valid  â”‚  Waiting...      â”‚  Waiting...    â”‚
â”‚  t2    â”‚  Consume parts   â”‚  Waiting...      â”‚  Waiting...    â”‚
â”‚  t3    â”‚  wheel:3â†’2       â”‚  Waiting...      â”‚  Waiting...    â”‚
â”‚  t4    â”‚  motor:2â†’1       â”‚  Waiting...      â”‚  Waiting...    â”‚
â”‚  t5    â”‚  LOCK released   â”‚  LOCK acquired   â”‚  Waiting...    â”‚
â”‚  t6    â”‚  âœ“ Success       â”‚  Check: âœ“ Valid  â”‚  Waiting...    â”‚
â”‚  t7    â”‚                  â”‚  Consume parts   â”‚  Waiting...    â”‚
â”‚  t8    â”‚                  â”‚  wheel:2â†’1       â”‚  Waiting...    â”‚
â”‚  t9    â”‚                  â”‚  motor:1â†’0       â”‚  Waiting...    â”‚
â”‚  t10   â”‚                  â”‚  LOCK released   â”‚  LOCK acquired â”‚
â”‚  t11   â”‚                  â”‚  âœ“ Success       â”‚  Check: âœ— Fail â”‚
â”‚  t12   â”‚                  â”‚                  â”‚  wheel:1 < 1   â”‚
â”‚  t13   â”‚                  â”‚                  â”‚  motor:0 < 1   â”‚
â”‚  t14   â”‚                  â”‚                  â”‚  LOCK released â”‚
â”‚  t15   â”‚                  â”‚                  â”‚  âœ— Failed      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Final Inventory: {wheel: 1, motor: 0}
Results:
  â€¢ Thread A: SUCCESS âœ“ (Robot 1 built)
  â€¢ Thread B: SUCCESS âœ“ (Robot 2 built)
  â€¢ Thread C: FAILED âœ— (Insufficient parts)

Correct: Only 2 robots built from parts for 2 robots!
```

---

### Counter Operations Deep Dive

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              COUNTER (HASHMAP) OPERATIONS                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Operation 1: Initialization
Input: ["wheel", "wheel", "motor", "sensor", "wheel"]

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Counter Internals (HashMap):                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Hash Table (size: 16, load factor: 0.75)        â”‚  â”‚
â”‚  â”‚                                                   â”‚  â”‚
â”‚  â”‚  Index  â”‚  Key      â”‚  Value                     â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚
â”‚  â”‚    3    â”‚  "wheel"  â”‚  3  â—„â”€â”€ 3 occurrences      â”‚  â”‚
â”‚  â”‚    7    â”‚  "motor"  â”‚  1                         â”‚  â”‚
â”‚  â”‚    11   â”‚  "sensor" â”‚  1                         â”‚  â”‚
â”‚  â”‚  other  â”‚  (empty)  â”‚  -                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                         â”‚
â”‚  Operations:                                            â”‚
â”‚    1. Loop: "wheel" â†’ hash("wheel") % 16 = 3           â”‚
â”‚       Check index 3: empty â†’ insert ("wheel", 1)       â”‚
â”‚    2. Loop: "wheel" â†’ hash("wheel") % 16 = 3           â”‚
â”‚       Check index 3: exists â†’ increment: 1 â†’ 2         â”‚
â”‚    3. Loop: "motor" â†’ hash("motor") % 16 = 7           â”‚
â”‚       Check index 7: empty â†’ insert ("motor", 1)       â”‚
â”‚    4. Loop: "sensor" â†’ hash("sensor") % 16 = 11        â”‚
â”‚       Check index 11: empty â†’ insert ("sensor", 1)     â”‚
â”‚    5. Loop: "wheel" â†’ hash("wheel") % 16 = 3           â”‚
â”‚       Check index 3: exists â†’ increment: 2 â†’ 3         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Operation 2: Subtraction (Consume Parts)
Counter 1: {"wheel": 3, "motor": 1}
Counter 2: {"wheel": 2, "motor": 1}  (requirements)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Subtraction Process:                                   â”‚
â”‚                                                         â”‚
â”‚  for part, count in requirements.items():               â”‚
â”‚      inventory[part] -= count                           â”‚
â”‚                                                         â”‚
â”‚  Step 1: "wheel"                                        â”‚
â”‚    inventory["wheel"] = 3 - 2 = 1                       â”‚
â”‚    Update hash table at index 3: 3 â†’ 1                 â”‚
â”‚                                                         â”‚
â”‚  Step 2: "motor"                                        â”‚
â”‚    inventory["motor"] = 1 - 1 = 0                       â”‚
â”‚    Update hash table at index 7: 1 â†’ 0                 â”‚
â”‚    if value == 0: delete entry (cleanup)               â”‚
â”‚                                                         â”‚
â”‚  Result:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Index  â”‚  Key      â”‚  Value                     â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚
â”‚  â”‚    3    â”‚  "wheel"  â”‚  1  â—„â”€â”€ Updated            â”‚ â”‚
â”‚  â”‚    7    â”‚  (deleted)â”‚  -  â—„â”€â”€ Removed            â”‚ â”‚
â”‚  â”‚    11   â”‚  "sensor" â”‚  1  â—„â”€â”€ Unchanged          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Time Complexity: O(1) per operation
  â€¢ Hash lookup: O(1) average
  â€¢ Increment/decrement: O(1)
  â€¢ Delete: O(1)
```

---

### Build Multiple Optimization

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           BUILD MULTIPLE ROBOTS (OPTIMIZED ALGORITHM)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Goal: Build as many identical robots as possible from inventory

Inventory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  wheel: 10                   â”‚
â”‚  motor: 5                    â”‚
â”‚  sensor: 8                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Robot Requirements: ["wheel", "wheel", "motor"]
Requirements Counter: {"wheel": 2, "motor": 1}

Calculate Maximum Buildable:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  For each required part:                                       â”‚
â”‚    max_from_this_part = inventory[part] // required[part]      â”‚
â”‚                                                                â”‚
â”‚  Part 1: "wheel"                                               â”‚
â”‚    Available: 10                                               â”‚
â”‚    Needed per robot: 2                                         â”‚
â”‚    Max robots from wheels: 10 // 2 = 5                         â”‚
â”‚                                                                â”‚
â”‚  Part 2: "motor"                                               â”‚
â”‚    Available: 5                                                â”‚
â”‚    Needed per robot: 1                                         â”‚
â”‚    Max robots from motors: 5 // 1 = 5                          â”‚
â”‚                                                                â”‚
â”‚  Bottleneck: min(5, 5) = 5 robots                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Batch Consumption:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Build 5 robots in one transaction:                           â”‚
â”‚                                                                â”‚
â”‚  wheel: consumed = 2 Ã— 5 = 10                                  â”‚
â”‚    inventory["wheel"] = 10 - 10 = 0                            â”‚
â”‚                                                                â”‚
â”‚  motor: consumed = 1 Ã— 5 = 5                                   â”‚
â”‚    inventory["motor"] = 5 - 5 = 0                              â”‚
â”‚                                                                â”‚
â”‚  sensor: not required = 0                                      â”‚
â”‚    inventory["sensor"] = 8 - 0 = 8  (unchanged)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Result:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Robots Built: 5             â”‚
â”‚                              â”‚
â”‚  Final Inventory:            â”‚
â”‚    wheel: 0                  â”‚
â”‚    motor: 0                  â”‚
â”‚    sensor: 8                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Efficiency: 1 transaction instead of 5!
```

---

### Part Substitution (Compatibility) System

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 PART COMPATIBILITY MAPPING                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Compatibility Rules:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Abstract Part  â”‚  Compatible Concrete Parts           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  "motor"        â”‚  ["motor_v1", "motor_v2"]            â”‚
â”‚  "sensor"       â”‚  ["sensor_basic", "sensor_advanced"] â”‚
â”‚  "wheel"        â”‚  ["wheel_standard"]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Inventory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  motor_v1: 2                   â”‚
â”‚  motor_v2: 1                   â”‚
â”‚  sensor_basic: 3               â”‚
â”‚  sensor_advanced: 1            â”‚
â”‚  wheel_standard: 4             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Build Request: ["motor", "sensor", "wheel", "wheel"]

Resolution Process:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Step 1: Resolve "motor" (need 1)                             â”‚
â”‚    Compatible: ["motor_v1", "motor_v2"]                        â”‚
â”‚    Strategy: Greedy selection                                  â”‚
â”‚      â€¢ motor_v1: have 2, take 1 âœ“                              â”‚
â”‚    Selected: motor_v1                                          â”‚
â”‚                                                                â”‚
â”‚  Step 2: Resolve "sensor" (need 1)                            â”‚
â”‚    Compatible: ["sensor_basic", "sensor_advanced"]             â”‚
â”‚    Strategy: Prefer basic (cheaper/common)                     â”‚
â”‚      â€¢ sensor_basic: have 3, take 1 âœ“                          â”‚
â”‚    Selected: sensor_basic                                      â”‚
â”‚                                                                â”‚
â”‚  Step 3: Resolve "wheel" (need 2)                             â”‚
â”‚    Compatible: ["wheel_standard"]                              â”‚
â”‚    Strategy: Only one option                                   â”‚
â”‚      â€¢ wheel_standard: have 4, take 2 âœ“                        â”‚
â”‚    Selected: wheel_standard Ã— 2                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Concrete Requirements (after substitution):
["motor_v1", "sensor_basic", "wheel_standard", "wheel_standard"]

Build with Concrete Parts:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Consume:                      â”‚
â”‚    motor_v1: 2 â†’ 1             â”‚
â”‚    sensor_basic: 3 â†’ 2         â”‚
â”‚    wheel_standard: 4 â†’ 2       â”‚
â”‚                                â”‚
â”‚  Final Inventory:              â”‚
â”‚    motor_v1: 1                 â”‚
â”‚    motor_v2: 1                 â”‚
â”‚    sensor_basic: 2             â”‚
â”‚    sensor_advanced: 1          â”‚
â”‚    wheel_standard: 2           â”‚
â”‚                                â”‚
â”‚  Status: SUCCESS âœ“              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Complexity Visualization

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OPERATION COMPLEXITY                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Operation        â”‚  Time       â”‚  Space    â”‚  Explanation      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  Initialize       â”‚  O(N)       â”‚  O(U)     â”‚  Count N parts,   â”‚
â”‚  Inventory        â”‚             â”‚           â”‚  U unique types   â”‚
â”‚                   â”‚             â”‚           â”‚                   â”‚
â”‚  can_build()      â”‚  O(R)       â”‚  O(R)     â”‚  Check R required â”‚
â”‚                   â”‚             â”‚           â”‚  parts            â”‚
â”‚                   â”‚             â”‚           â”‚                   â”‚
â”‚  build()          â”‚  O(R)       â”‚  O(R)     â”‚  Validate + updateâ”‚
â”‚                   â”‚             â”‚           â”‚  R parts          â”‚
â”‚                   â”‚             â”‚           â”‚                   â”‚
â”‚  build_multiple() â”‚  O(R)       â”‚  O(R)     â”‚  Calculate once,  â”‚
â”‚                   â”‚             â”‚           â”‚  batch consume    â”‚
â”‚                   â”‚             â”‚           â”‚                   â”‚
â”‚  restock()        â”‚  O(P)       â”‚  O(1)     â”‚  Add P parts      â”‚
â”‚                   â”‚             â”‚           â”‚  incrementally    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Memory Layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Counter (HashMap):                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Overhead: ~200 bytes                                â”‚  â”‚
â”‚  â”‚  Per Entry: ~64 bytes (string + int + hash metadata)â”‚  â”‚
â”‚  â”‚                                                      â”‚  â”‚
â”‚  â”‚  Example: 100 unique part types                     â”‚  â”‚
â”‚  â”‚    Memory: 200 + (100 Ã— 64) = 6,600 bytes â‰ˆ 6.4 KB  â”‚  â”‚
â”‚  â”‚    Very efficient!                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                            â”‚
â”‚  Lock: ~40 bytes                                           â”‚
â”‚  Total: O(U) space where U = unique parts                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ Examples

### Example 1: Basic Usage
```python
builder = RobotBuilder(["wheel", "wheel", "motor", "sensor"])

# Build robot 1
success, msg = builder.build(["wheel", "motor"])
print(success)  # True
print(builder.get_inventory())  # {"wheel": 1, "sensor": 1}

# Build robot 2
success, msg = builder.build(["wheel", "sensor"])
print(success)  # True
print(builder.get_inventory())  # {}
```

### Example 2: Insufficient Inventory
```python
builder = RobotBuilder(["wheel", "motor"])

success, msg = builder.build(["wheel", "wheel", "motor"])
print(success)  # False
print(msg)      # ["wheel (need 2, have 1)"]
```

---

## ğŸ—£ï¸ Interview Conversation Guide

### Phase 1: Clarification (3-5 min)

**Candidate:** "Does the order of parts matter? Is `[A, B]` the same as `[B, A]`?"
**Interviewer:** "Order doesn't matter. Think of it as a multiset (bag)."

**Candidate:** "Can the requirements have duplicates?"
**Interviewer:** "Yes, a robot might need 4 wheels and 2 motors."

**Candidate:** "Should the operation be atomic? If I can't build a robot, should the inventory remain unchanged?"
**Interviewer:** "Yes, it's a transaction. Either all parts are consumed, or none."

**Candidate:** "Are part names case-sensitive?"
**Interviewer:** "Yes. 'Wheel' and 'wheel' are different parts."

### Phase 2: Approach Discussion (5-8 min)

**Candidate:** "This is a **frequency matching** problem. Since we care about **how many** of each part (not just presence), a `Set` won't work. We need a **frequency map** (HashMap or Counter).

**Data Structure:**
- Store inventory as `Map<part_name, count>`.
- For each build request, create a frequency map of requirements.
- Compare: `inventory[part] >= required[part]` for all parts.

**Algorithm:**
1. **Check Phase:** Validate all parts are available in sufficient quantity.
2. **Update Phase:** If check passes, decrement inventory counts atomically.

**Why Atomic?** If we check then update separately without locking, another thread might consume parts in between."

### Phase 3: Implementation (10-15 min)

**Candidate:** "I'll use Python's `Counter` for clean frequency mapping."

---

## ğŸ§  Intuition & Approach

### Why HashMap (Counter)?

**Problem Requirements:**
- Track **quantity** of each part, not just presence.
- Fast lookup: "Do we have enough of part X?"
- Fast update: "Remove N units of part X."

**Counter Properties:**
- O(1) lookup and update
- Handles missing keys gracefully (returns 0)
- Built-in operations like subtraction

### Transaction Pattern

```text
1. Create a "snapshot" of requirements
2. Validate ALL requirements
3. If ANY fail, abort (don't modify inventory)
4. If ALL succeed, commit changes

This is the classic "Check-Then-Act" race condition pattern.
In concurrent systems, need locking.
```

---

## ğŸ“ Solution 0: Ultra-Simplified (No Classes - Interview Speed Coding)

**Perfect for 20-30 minute interviews.** Uses only Counter and functions.

```python
from collections import Counter

# Global inventory (or pass as parameter)
inventory = Counter()

def initialize_inventory(parts_list):
    """Initialize inventory from list of parts."""
    global inventory
    inventory = Counter(parts_list)

def can_build(requirements):
    """
    Check if robot can be built.
    
    Args:
        requirements: List of part names needed
    
    Returns:
        True if all parts available
    """
    required = Counter(requirements)
    
    for part, needed in required.items():
        if inventory[part] < needed:
            return False
    
    return True

def build_robot(requirements):
    """
    Build robot if possible, consuming parts.
    
    Args:
        requirements: List of part names needed
    
    Returns:
        (success, missing_parts)
    """
    required = Counter(requirements)
    missing = []
    
    # Phase 1: Validate ALL parts first
    for part, needed in required.items():
        have = inventory[part]
        if have < needed:
            missing.append(f"{part} (need {needed}, have {have})")
    
    # Phase 2: Only consume if all available
    if missing:
        return False, missing
    
    # Consume parts atomically
    for part, count in required.items():
        inventory[part] -= count
        if inventory[part] == 0:
            del inventory[part]
    
    return True, []

def get_inventory():
    """Return current inventory as dict."""
    return dict(inventory)


# ============================================
# COMPLETE RUNNABLE EXAMPLE
# ============================================

if __name__ == "__main__":
    print("=" * 60)
    print("ROBOT PARTS ASSEMBLY - ULTRA SIMPLIFIED")
    print("=" * 60)
    
    # Test 1: Basic build
    print("\n[Test 1] Basic Robot Build")
    print("-" * 40)
    initialize_inventory([
        "wheel", "wheel", "wheel", "wheel",
        "motor", "motor",
        "sensor", "camera"
    ])
    
    print(f"Initial Inventory: {get_inventory()}")
    
    success, msg = build_robot(["wheel", "wheel", "motor"])
    print(f"\nBuild Robot 1: {success}")
    print(f"Inventory After: {get_inventory()}")
    
    # Test 2: Insufficient parts
    print("\n[Test 2] Insufficient Parts")
    print("-" * 40)
    success, msg = build_robot(["wheel", "wheel", "wheel", "motor"])
    print(f"Build Robot 2: {success}")
    if not success:
        print(f"Missing: {msg}")
    print(f"Inventory (unchanged): {get_inventory()}")
    
    # Test 3: Multiple robots
    print("\n[Test 3] Build Maximum Robots")
    print("-" * 40)
    initialize_inventory(["wheel"] * 10 + ["motor"] * 5)
    
    robots_built = 0
    while can_build(["wheel", "wheel", "motor"]):
        build_robot(["wheel", "wheel", "motor"])
        robots_built += 1
    
    print(f"Built {robots_built} robots")
    print(f"Remaining: {get_inventory()}")
    
    # Test 4: Edge cases
    print("\n[Test 4] Edge Cases")
    print("-" * 40)
    
    # Empty requirements
    success, msg = build_robot([])
    print(f"Build robot with no requirements: {success}")
    
    # Empty inventory
    initialize_inventory([])
    success, msg = build_robot(["wheel"])
    print(f"Build from empty inventory: {success}, Missing: {msg}")
    
    print("\n" + "=" * 60)
    print("âœ… All tests passed!")
    print("=" * 60)
    
    print("\nğŸ’¡ Key Points:")
    print("  â€¢ Counter automatically handles counts")
    print("  â€¢ Validate ALL before consuming (atomic)")
    print("  â€¢ No classes needed - just functions")
```

**Why This Works:**
- âœ… **Counter** handles frequency tracking automatically
- âœ… **Atomic** - all-or-nothing transaction
- âœ… **Simple** - ~50 lines of core logic
- âœ… **Fast to code** - perfect for interviews

---

## ğŸ“ Solution 1: Production-Ready (With Thread Safety)

If interviewer asks for thread safety or you have extra time:

```python
from collections import Counter
from typing import List, Tuple, Dict, Optional
import threading

class RobotBuilder:
    """
    Manage robot assembly with inventory tracking.
    
    Supports:
    - Check if robot can be built
    - Build robot (consume parts atomically)
    - Query current inventory
    """
    
    def __init__(self, initial_inventory: List[str]):
        """
        Initialize builder with inventory.
        
        Args:
            initial_inventory: List of part names (can have duplicates)
        
        Time: O(N) where N = number of parts
        Space: O(U) where U = unique parts
        """
        self.inventory = Counter(initial_inventory)
        self.lock = threading.Lock()  # For thread safety
    
    def can_build(self, requirements: List[str]) -> bool:
        """
        Check if robot can be built (non-destructive).
        
        Args:
            requirements: List of required part names
        
        Returns:
            True if all parts available in sufficient quantity
        
        Time: O(R) where R = number of requirements
        Space: O(U) for requirement counter
        """
        required = Counter(requirements)
        
        for part, count in required.items():
            if self.inventory[part] < count:
                return False
        
        return True
    
    def build(self, requirements: List[str]) -> Tuple[bool, List[str]]:
        """
        Attempt to build robot. Consumes parts if successful.
        
        Args:
            requirements: List of required part names
        
        Returns:
            (success, messages):
                - If success: (True, [])
                - If failure: (False, ["part1 (need X, have Y)", ...])
        
        Time: O(R) where R = number of requirements
        Space: O(U) for tracking
        """
        with self.lock:  # Ensure atomicity
            required = Counter(requirements)
            missing = []
            
            # Phase 1: Validation
            for part, needed in required.items():
                available = self.inventory[part]
                if available < needed:
                    shortage = needed - available
                    missing.append(f"{part} (need {needed}, have {available})")
            
            # Phase 2: Commit or Abort
            if missing:
                return False, missing
            
            # All parts available, consume them
            for part, count in required.items():
                self.inventory[part] -= count
                # Optional: Remove zero-count entries
                if self.inventory[part] == 0:
                    del self.inventory[part]
            
            return True, []
    
    def build_multiple(self, requirements: List[str], quantity: int) -> Tuple[int, List[str]]:
        """
        Build multiple identical robots.
        
        Args:
            requirements: Parts for one robot
            quantity: Number of robots to build
        
        Returns:
            (built_count, message):
                - built_count: How many robots were successfully built
                - message: Error messages if any
        """
        with self.lock:
            # Check maximum buildable
            required = Counter(requirements)
            max_buildable = quantity
            
            for part, needed_per_robot in required.items():
                available = self.inventory[part]
                can_build = available // needed_per_robot
                max_buildable = min(max_buildable, can_build)
            
            if max_buildable == 0:
                return 0, [f"Cannot build even 1 robot"]
            
            # Build max_buildable robots
            for part, needed_per_robot in required.items():
                total_needed = needed_per_robot * max_buildable
                self.inventory[part] -= total_needed
                if self.inventory[part] == 0:
                    del self.inventory[part]
            
            return max_buildable, []
    
    def get_inventory(self) -> Dict[str, int]:
        """
        Get current inventory snapshot.
        
        Time: O(U)
        Space: O(U)
        """
        with self.lock:
            return dict(self.inventory)
    
    def restock(self, parts: List[str]) -> None:
        """
        Add parts to inventory.
        
        Time: O(P) where P = number of parts to add
        """
        with self.lock:
            for part in parts:
                self.inventory[part] += 1


# ============================================
# COMPLETE RUNNABLE EXAMPLE
# ============================================

if __name__ == "__main__":
    print("=" * 60)
    print("ROBOT PARTS ASSEMBLY SYSTEM")
    print("=" * 60)
    
    # Test 1: Basic build
    print("\n[Test 1] Basic Robot Build")
    print("-" * 40)
    builder = RobotBuilder([
        "wheel", "wheel", "wheel", "wheel",
        "motor", "motor",
        "sensor", "camera"
    ])
    
    print("Initial Inventory:", builder.get_inventory())
    
    success, msg = builder.build(["wheel", "wheel", "motor"])
    print(f"\nBuild Robot 1: {success}")
    print(f"Inventory After: {builder.get_inventory()}")
    
    # Test 2: Insufficient parts
    print("\n[Test 2] Insufficient Parts")
    print("-" * 40)
    success, msg = builder.build(["wheel", "wheel", "wheel", "motor"])
    print(f"Build Robot 2: {success}")
    if not success:
        print(f"Missing: {msg}")
    print(f"Inventory (unchanged): {builder.get_inventory()}")
    
    # Test 3: Multiple robots
    print("\n[Test 3] Build Multiple Identical Robots")
    print("-" * 40)
    builder2 = RobotBuilder(["wheel"] * 10 + ["motor"] * 5)
    
    built, msg = builder2.build_multiple(["wheel", "wheel", "motor"], quantity=5)
    print(f"Attempted to build 5 robots")
    print(f"Successfully built: {built} robots")
    print(f"Inventory After: {builder2.get_inventory()}")
    
    # Test 4: Restock
    print("\n[Test 4] Restock Inventory")
    print("-" * 40)
    builder.restock(["wheel", "wheel", "motor"])
    print(f"Restocked: 2 wheels, 1 motor")
    print(f"Inventory: {builder.get_inventory()}")
    
    success, msg = builder.build(["wheel", "wheel", "motor"])
    print(f"Build Robot 3: {success}")
    print(f"Inventory After: {builder.get_inventory()}")
    
    # Test 5: Edge cases
    print("\n[Test 5] Edge Cases")
    print("-" * 40)
    
    # Empty requirements
    success, msg = builder.build([])
    print(f"Build robot with no requirements: {success}")
    
    # Empty inventory
    builder_empty = RobotBuilder([])
    success, msg = builder_empty.build(["wheel"])
    print(f"Build from empty inventory: {success}, Missing: {msg}")
    
    print("\n" + "=" * 60)
    print("All tests passed! âœ“")
    print("=" * 60)
```

---

## ğŸ” Explanation with Example

Let's trace through the inventory management system with a concrete example:

**Initial Inventory:** `["wheel", "wheel", "wheel", "motor", "sensor", "sensor"]`

**Requirements:** `["wheel", "wheel", "motor"]`

---

**Step 1: Initialize Builder**

```python
builder = RobotBuilder(["wheel", "wheel", "wheel", "motor", "sensor", "sensor"])

# Internal state:
inventory = Counter({
    "wheel": 3,
    "motor": 1,
    "sensor": 2
})
```

---

**Step 2: Check if Can Build**

```python
requirements = ["wheel", "wheel", "motor"]
req_count = Counter(requirements)
# Result: {"wheel": 2, "motor": 1}
```

**Validation:**
```text
Check "wheel": need 2, have 3 âœ“
Check "motor": need 1, have 1 âœ“

All requirements satisfied!
```

**Result:** `can_build() = True`

---

**Step 3: Build Robot (Consume Parts)**

Since validation passed, consume parts atomically:

```python
for part, needed in req_count.items():
    inventory[part] -= needed
```

**Updates:**
```text
wheel: 3 - 2 = 1
motor: 1 - 1 = 0
```

**New Inventory State:**
```python
inventory = Counter({
    "wheel": 1,
    "motor": 0,  # Will be removed (0 count)
    "sensor": 2
})

# After cleanup (remove zero counts):
inventory = Counter({
    "wheel": 1,
    "sensor": 2
})
```

**Result:** `build() = (True, "Success")`

---

**Example 2: Insufficient Parts**

Now try to build another robot needing `["wheel", "wheel", "motor"]`:

**Current Inventory:** `{"wheel": 1, "sensor": 2}`

**Validation:**
```text
Check "wheel": need 2, have 1 âœ— MISSING!
Check "motor": need 1, have 0 âœ— MISSING!
```

**Missing Parts Calculation:**
```python
missing = {
    "wheel": 2 - 1 = 1,
    "motor": 1 - 0 = 1
}
```

**Result:** 
```python
build() = (
    False, 
    {"wheel": "need 1 more", "motor": "need 1 more"}
)
```

**Inventory Unchanged** (atomic transaction failed):
```python
inventory = Counter({
    "wheel": 1,
    "sensor": 2
})
```

---

**Key Points:**

1. **Counter** provides O(1) lookup and updates
2. **Validation happens before modification** (atomic)
3. **Missing parts are calculated** for user feedback
4. **Transaction either fully succeeds or fails** (no partial builds)

---

## ğŸ” Complexity Analysis

### Time Complexity

| Operation | Time | Explanation |
|-----------|------|-------------|
| `__init__()` | **O(N)** | Count N initial parts |
| `can_build()` | **O(R)** | Check R requirements |
| `build()` | **O(R)** | Validate + update R requirements |
| `build_multiple()` | **O(R)** | Same as single build |
| `get_inventory()` | **O(U)** | Copy U unique parts |
| `restock()` | **O(P)** | Add P new parts |

**Where:**
- N = total initial parts
- R = requirements size
- U = unique part types
- P = parts to restock

### Space Complexity

**O(U)** where U = number of unique part types.

---

## âš ï¸ Common Pitfalls

### 1. **Partial Updates (Race Condition)**

**Wrong:**
```python
def build(self, requirements):
    for part in requirements:
        if self.inventory[part] > 0:
            self.inventory[part] -= 1  # Immediate update!
        else:
            return False, [f"Missing {part}"]
    return True, []
```

**Problem:** If the 5th part is missing, we already consumed parts 1-4. The inventory is corrupted.

**Right:** Validate ALL parts first, then update atomically.

### 2. **Forgetting to Handle Duplicates**

**Wrong:**
```python
required = set(requirements)  # Loses count!
```

**Problem:** `["wheel", "wheel"]` becomes `{"wheel"}`. We only check for 1 wheel instead of 2.

**Right:** Use `Counter` to preserve frequencies.

### 3. **Not Thread-Safe**

**Wrong:**
```python
def build(self, requirements):
    if self.can_build(requirements):  # Check
        # Another thread might modify here!
        self._consume(requirements)     # Update
```

**Problem:** Between check and update, another thread might consume parts.

**Right:** Use a lock around the entire check-update block.

---

## ğŸ”„ Follow-up Questions

### Follow-up 1: Thread Safety with Concurrent Builds

**Problem Statement:**
> "Multiple robots are being built concurrently from the same inventory. Ensure thread safety."

**Solution:**
Already implemented with `threading.Lock()` in the base solution. The `with self.lock` ensures the check-update block is atomic.

**Example:**

```python
import threading
import time

def worker(builder, robot_id, requirements):
    """Simulate a worker trying to build a robot."""
    print(f"Robot {robot_id}: Attempting to build...")
    success, msg = builder.build(requirements)
    if success:
        print(f"Robot {robot_id}: âœ“ Built successfully")
    else:
        print(f"Robot {robot_id}: âœ— Failed - {msg}")

# ============================================
# EXAMPLE: Concurrent Builds
# ============================================

if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("FOLLOW-UP 1: CONCURRENT BUILDS")
    print("=" * 60)
    
    # Start with limited inventory
    builder = RobotBuilder(["wheel"] * 5 + ["motor"] * 3)
    
    print(f"Initial Inventory: {builder.get_inventory()}")
    
    # Create 5 threads trying to build robots
    threads = []
    for i in range(5):
        requirements = ["wheel", "motor"]
        t = threading.Thread(target=worker, args=(builder, i+1, requirements))
        threads.append(t)
        t.start()
    
    # Wait for all threads
    for t in threads:
        t.join()
    
    print(f"\nFinal Inventory: {builder.get_inventory()}")
    print("Only 3 robots should have been built (limited by 3 motors)")
```

**Output:**
```
Initial Inventory: {'wheel': 5, 'motor': 3}
Robot 1: âœ“ Built successfully
Robot 2: âœ“ Built successfully
Robot 3: âœ“ Built successfully
Robot 4: âœ— Failed - ['motor (need 1, have 0)']
Robot 5: âœ— Failed - ['motor (need 1, have 0)']
Final Inventory: {'wheel': 2}
```

---

### Follow-up 2: Priority Queue for Build Requests

**Problem Statement:**
> "Some robots are high-priority (urgent orders). Process high-priority builds first, even if they arrive later."

**Solution:**
Use a **Priority Queue** (heap) to store build requests.

```python
import heapq

class PriorityRobotBuilder(RobotBuilder):
    """
    Robot builder with priority queue for build requests.
    """
    
    def __init__(self, initial_inventory: List[str]):
        super().__init__(initial_inventory)
        self.build_queue = []  # Min-heap: (priority, timestamp, requirements)
        self.timestamp = 0
    
    def add_build_request(self, requirements: List[str], priority: int = 0) -> None:
        """
        Add build request to queue.
        
        Args:
            requirements: Parts needed
            priority: Lower number = higher priority (0 is highest)
        
        Time: O(log Q) where Q = queue size
        """
        with self.lock:
            heapq.heappush(
                self.build_queue,
                (priority, self.timestamp, requirements)
            )
            self.timestamp += 1
    
    def process_next(self) -> Tuple[bool, Optional[List[str]]]:
        """
        Process highest-priority build request.
        
        Returns:
            (success, requirements_or_message)
        
        Time: O(log Q + R)
        """
        with self.lock:
            if not self.build_queue:
                return False, None
            
            priority, ts, requirements = heapq.heappop(self.build_queue)
        
        # Try to build (uses parent's atomic build method)
        success, msg = self.build(requirements)
        
        if not success:
            # Re-queue if failed (or handle differently)
            with self.lock:
                heapq.heappush(self.build_queue, (priority, ts, requirements))
        
        return success, requirements if success else msg


# ============================================
# EXAMPLE
# ============================================

if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("FOLLOW-UP 2: PRIORITY QUEUE")
    print("=" * 60)
    
    builder = PriorityRobotBuilder(["wheel"] * 10 + ["motor"] * 5)
    
    # Add requests (lower priority number = higher priority)
    builder.add_build_request(["wheel", "motor"], priority=2)  # Low priority
    builder.add_build_request(["wheel", "motor"], priority=0)  # High priority
    builder.add_build_request(["wheel", "motor"], priority=1)  # Medium priority
    
    print("Processing requests by priority...")
    for i in range(3):
        success, result = builder.process_next()
        print(f"  Request {i+1}: {success}, Requirements: {result}")
```

---

### Follow-up 3: Substitutions (Part Compatibility)

**Problem Statement:**
> "Some parts are interchangeable. For example, 'motor_v1' and 'motor_v2' can both fulfill a 'motor' requirement. How do you handle this?"

**Solution:**
Maintain a **compatibility map**:

```python
class FlexibleRobotBuilder(RobotBuilder):
    """
    Robot builder with part substitutions.
    """
    
    def __init__(self, initial_inventory: List[str], compatibility: Dict[str, List[str]]):
        """
        Args:
            initial_inventory: Parts list
            compatibility: Map from abstract part to compatible concrete parts
                Example: {"motor": ["motor_v1", "motor_v2"]}
        """
        super().__init__(initial_inventory)
        self.compatibility = compatibility
    
    def _find_available(self, abstract_part: str, needed: int) -> Optional[List[str]]:
        """
        Find concrete parts that can fulfill the requirement.
        
        Returns:
            List of concrete part names if sufficient, else None
        """
        compatible = self.compatibility.get(abstract_part, [abstract_part])
        
        # Try to gather needed quantity from compatible parts
        selected = []
        remaining = needed
        
        for concrete_part in compatible:
            available = self.inventory.get(concrete_part, 0)
            take = min(available, remaining)
            selected.extend([concrete_part] * take)
            remaining -= take
            
            if remaining == 0:
                return selected
        
        return None if remaining > 0 else selected
    
    def build_with_substitution(self, requirements: List[str]) -> Tuple[bool, List[str]]:
        """
        Build robot, allowing part substitutions.
        """
        with self.lock:
            # Map requirements to concrete parts
            concrete_requirements = []
            
            for abstract_part in requirements:
                selected = self._find_available(abstract_part, 1)
                if selected is None:
                    return False, [f"Cannot fulfill {abstract_part}"]
                concrete_requirements.extend(selected)
            
            # Now build with concrete parts
            return self.build(concrete_requirements)


# ============================================
# COMPLETE RUNNABLE EXAMPLE
# ============================================

if __name__ == "__main__":
    from collections import Counter
    from typing import List, Tuple, Dict, Optional
    import threading
    
    class RobotBuilder:
        """Base robot builder (simplified for this example)."""
        def __init__(self, initial_inventory: List[str]):
            self.inventory = Counter(initial_inventory)
            self.lock = threading.Lock()
        
        def build(self, requirements: List[str]) -> Tuple[bool, List[str]]:
            """Build robot with given requirements."""
            with self.lock:
                required = Counter(requirements)
                missing = []
                
                # Validate
                for part, needed in required.items():
                    available = self.inventory[part]
                    if available < needed:
                        missing.append(f"{part} (need {needed}, have {available})")
                
                if missing:
                    return False, missing
                
                # Consume
                for part, count in required.items():
                    self.inventory[part] -= count
                    if self.inventory[part] == 0:
                        del self.inventory[part]
                
                return True, []
        
        def get_inventory(self) -> Dict[str, int]:
            """Get current inventory."""
            with self.lock:
                return dict(self.inventory)
    
    class FlexibleRobotBuilder(RobotBuilder):
        """
        Robot builder with part substitutions.
        
        Allows abstract parts to be fulfilled by compatible concrete parts.
        """
        
        def __init__(self, initial_inventory: List[str], compatibility: Dict[str, List[str]]):
            """
            Args:
                initial_inventory: Parts list
                compatibility: Map from abstract part to compatible concrete parts
                    Example: {"motor": ["motor_v1", "motor_v2"]}
            """
            super().__init__(initial_inventory)
            self.compatibility = compatibility
        
        def _find_available(self, abstract_part: str, needed: int) -> Optional[List[str]]:
            """
            Find concrete parts that can fulfill the requirement.
            
            Strategy: Greedy selection from compatible parts.
            
            Returns:
                List of concrete part names if sufficient, else None
            """
            compatible = self.compatibility.get(abstract_part, [abstract_part])
            
            # Try to gather needed quantity from compatible parts
            selected = []
            remaining = needed
            
            for concrete_part in compatible:
                available = self.inventory.get(concrete_part, 0)
                take = min(available, remaining)
                selected.extend([concrete_part] * take)
                remaining -= take
                
                if remaining == 0:
                    return selected
            
            return None if remaining > 0 else selected
        
        def build_with_substitution(self, requirements: List[str]) -> Tuple[bool, List[str]]:
            """
            Build robot, allowing part substitutions.
            
            Time: O(R Ã— C) where R=requirements, C=compatible parts per requirement
            Space: O(R)
            """
            with self.lock:
                # Map requirements to concrete parts
                concrete_requirements = []
                
                for abstract_part in requirements:
                    selected = self._find_available(abstract_part, 1)
                    if selected is None:
                        return False, [f"Cannot fulfill {abstract_part}"]
                    concrete_requirements.extend(selected)
                
                # Now build with concrete parts
                return self.build(concrete_requirements)
    
    print("\n" + "=" * 70)
    print("FOLLOW-UP 3: PART SUBSTITUTIONS (COMPATIBILITY)")
    print("=" * 70)
    
    # Setup: Define compatibility rules
    compatibility = {
        "motor": ["motor_v1", "motor_v2", "motor_v3"],
        "sensor": ["sensor_basic", "sensor_advanced"],
        "wheel": ["wheel_standard", "wheel_allterrain"]
    }
    
    print("\nğŸ“‹ Compatibility Rules:")
    print("-" * 70)
    for abstract, concrete in compatibility.items():
        print(f"  {abstract:10} â†’ {', '.join(concrete)}")
    
    # Initial inventory (only concrete parts)
    inventory = [
        "motor_v1", "motor_v1",
        "motor_v2",
        "sensor_basic", "sensor_basic", "sensor_basic",
        "sensor_advanced",
        "wheel_standard", "wheel_standard", "wheel_standard", "wheel_standard",
    ]
    
    builder = FlexibleRobotBuilder(inventory, compatibility)
    
    print("\nğŸ“¦ Initial Inventory:")
    print("-" * 70)
    for part, count in sorted(builder.get_inventory().items()):
        print(f"  {part:20} Ã— {count}")
    
    # Test 1: Build robot with abstract requirements
    print("\n" + "=" * 70)
    print("[Test 1] Build Robot with Abstract Requirements")
    print("-" * 70)
    
    requirements = ["motor", "motor", "sensor", "wheel", "wheel"]
    print(f"\nRequirements (abstract): {requirements}")
    
    success, msg = builder.build_with_substitution(requirements)
    print(f"\nBuild Status: {'âœ… SUCCESS' if success else 'âŒ FAILED'}")
    if not success:
        print(f"Missing: {msg}")
    
    print(f"\nInventory After Build:")
    for part, count in sorted(builder.get_inventory().items()):
        print(f"  {part:20} Ã— {count}")
    
    print(f"\nğŸ’¡ Explanation:")
    print(f"  â€¢ 'motor' matched to: motor_v1 (available)")
    print(f"  â€¢ 'motor' matched to: motor_v1 (second available)")
    print(f"  â€¢ 'sensor' matched to: sensor_basic (most common)")
    print(f"  â€¢ 'wheel' matched to: wheel_standard Ã— 2")
    
    # Test 2: Build when preferred part runs out
    print("\n" + "=" * 70)
    print("[Test 2] Fallback to Alternative Parts")
    print("-" * 70)
    
    requirements2 = ["motor", "sensor", "sensor"]
    print(f"\nRequirements: {requirements2}")
    
    print(f"\nBefore: motor_v1={builder.inventory.get('motor_v1', 0)}, "
          f"motor_v2={builder.inventory.get('motor_v2', 0)}")
    
    success, msg = builder.build_with_substitution(requirements2)
    print(f"\nBuild Status: {'âœ… SUCCESS' if success else 'âŒ FAILED'}")
    
    print(f"\nAfter: motor_v1={builder.inventory.get('motor_v1', 0)}, "
          f"motor_v2={builder.inventory.get('motor_v2', 0)}")
    
    print(f"\nğŸ’¡ Explanation:")
    print(f"  â€¢ motor_v1 ran out, so motor_v2 was used!")
    print(f"  â€¢ Automatic fallback to compatible parts")
    
    # Test 3: Cannot build (insufficient compatible parts)
    print("\n" + "=" * 70)
    print("[Test 3] Insufficient Compatible Parts")
    print("-" * 70)
    
    # Try to build 10 motors (we don't have enough)
    requirements3 = ["motor"] * 10
    print(f"\nRequirements: {len(requirements3)} motors")
    
    success, msg = builder.build_with_substitution(requirements3)
    print(f"\nBuild Status: {'âœ… SUCCESS' if success else 'âŒ FAILED'}")
    if not success:
        print(f"Reason: {msg}")
    
    print(f"\nAvailable motors:")
    for part in ["motor_v1", "motor_v2", "motor_v3"]:
        count = builder.inventory.get(part, 0)
        print(f"  {part:15} Ã— {count}")
    
    # Test 4: Mixed abstract and concrete requirements
    print("\n" + "=" * 70)
    print("[Test 4] Mixed Abstract and Concrete Requirements")
    print("-" * 70)
    
    # Add more inventory
    builder2 = FlexibleRobotBuilder(
        ["motor_v1", "motor_v2", "sensor_basic", "wheel_standard", "wheel_standard"],
        compatibility
    )
    
    # Requirements: Some abstract, some concrete
    requirements4 = ["motor_v1", "sensor", "wheel_standard"]
    print(f"\nRequirements: {requirements4}")
    print(f"  (Mix of concrete and abstract)")
    
    success, msg = builder2.build_with_substitution(requirements4)
    print(f"\nBuild Status: {'âœ… SUCCESS' if success else 'âŒ FAILED'}")
    
    print(f"\nInventory After:")
    for part, count in sorted(builder2.get_inventory().items()):
        print(f"  {part:20} Ã— {count}")
    
    print("\n" + "=" * 70)
    print("âœ… Part substitution tests complete!")
    print("=" * 70)
    
    print("\nğŸ¯ Key Benefits of Part Compatibility:")
    print("  â€¢ Flexibility: Use any compatible part")
    print("  â€¢ Efficiency: Maximize inventory utilization")
    print("  â€¢ Scalability: Easy to add new part versions")
    print("  â€¢ Real-world: Mimics actual manufacturing")
```

---

## ğŸ§ª Test Cases

```python
def test_robot_builder():
    # Test 1: Exact match
    builder = RobotBuilder(["A", "B"])
    assert builder.can_build(["A", "B"]) == True
    
    # Test 2: Insufficient quantity
    builder = RobotBuilder(["A"])
    assert builder.can_build(["A", "A"]) == False
    
    # Test 3: Missing part
    builder = RobotBuilder(["A"])
    assert builder.can_build(["B"]) == False
    
    # Test 4: Successful build
    builder = RobotBuilder(["A", "A", "B"])
    success, _ = builder.build(["A", "B"])
    assert success == True
    assert builder.get_inventory() == {"A": 1}
    
    # Test 5: Failed build doesn't modify inventory
    builder = RobotBuilder(["A"])
    inv_before = builder.get_inventory().copy()
    success, _ = builder.build(["A", "A"])
    assert success == False
    assert builder.get_inventory() == inv_before
    
    print("All tests passed! âœ“")

if __name__ == "__main__":
    test_robot_builder()
```

---

## ğŸ¯ Key Takeaways

1. **Counter is Perfect for Frequency Matching** problems.
2. **Atomic Transactions** require validation before modification.
3. **Thread Safety** needs locking around check-update blocks.
4. **Priority Queues** enable sophisticated scheduling.
5. **Flexibility** (substitutions) requires mapping abstract â†’ concrete parts.

---

## ğŸ“š Related Problems

- **LeetCode 383:** Ransom Note (simpler: no duplicates matter)
- **LeetCode 242:** Valid Anagram (frequency matching)
- **LeetCode 49:** Group Anagrams (frequency as key)
- **LeetCode 1160:** Find Words That Can Be Formed by Characters
